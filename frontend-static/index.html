<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Maps Pro — Live Tracking + Waypoint Dialog</title>

    <!-- External Dependencies -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

    <style>
        /* =============================================================================
           CSS CUSTOM PROPERTIES & BASE STYLES
        ============================================================================= */
        :root {
            --primary: #1a73e8;
            --primary-weak: rgba(26, 115, 232, 0.12);
            --success: #0f9d58;
            --danger: #ea4335;
            --warning: #fbbc05;
            --text: #202124;
            --muted: #5f6368;
            --card: #ffffff;
            --bg: #f7f8fb;
            --radius: 14px;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            --shadow-sm: 0 6px 16px rgba(0, 0, 0, 0.08);
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text);
            background:
                radial-gradient(1250px 650px at 80% -20%, #e7f0ff 0%, transparent 60%),
                radial-gradient(1000px 650px at -20% -20%, #e8fff1 0%, transparent 60%),
                var(--bg);
            overflow: hidden;
        }

        /* =============================================================================
           HEADER COMPONENTS
        ============================================================================= */
        .header {
            height: 64px;
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0 18px;
            background: var(--card);
            box-shadow: var(--shadow-sm);
            position: relative;
            z-index: 1000;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: grid;
            place-items: center;
            color: #fff;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), #34a853);
            box-shadow: inset 0 -6px 18px rgba(0, 0, 0, 0.18);
        }

        .title {
            font-weight: 800;
            letter-spacing: 0.2px;
        }

        .badge {
            font-size: 12px;
            color: #fff;
            background: var(--primary);
            padding: 6px 10px;
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        /* =============================================================================
           SEARCH & DROPDOWN COMPONENTS
        ============================================================================= */
        .search {
            flex: 1;
            max-width: 640px;
            position: relative;
        }

        .search input {
            width: 100%;
            height: 42px;
            padding: 0 44px 0 14px;
            border-radius: 999px;
            border: 1px solid #e3e6ea;
            outline: none;
            transition: 0.2s;
            box-shadow: inset 0 0 0 1px #fff;
            font-size: 14px;
        }

        .search input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px var(--primary-weak);
        }

        .search .icon {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--muted);
        }

        .dropdown {
            position: absolute;
            top: 44px;
            left: 0;
            right: 0;
            background: var(--card);
            border-radius: 12px;
            box-shadow: var(--shadow);
            display: none;
            max-height: 260px;
            overflow: auto;
            z-index: 1200;
        }

        .dropdown .item {
            padding: 10px 12px;
            border-bottom: 1px solid #f4f6f9;
            cursor: pointer;
        }

        .dropdown .item:last-child {
            border-bottom: 0;
        }

        .dropdown .name {
            font-weight: 700;
            font-size: 14px;
        }

        .dropdown .addr {
            font-size: 12px;
            color: var(--muted);
        }

        /* =============================================================================
           BUTTON COMPONENTS
        ============================================================================= */
        .actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .circle-btn {
            width: 40px;
            height: 40px;
            border: 0;
            border-radius: 50%;
            background: #f1f3f4;
            display: grid;
            place-items: center;
            cursor: pointer;
            transition: 0.15s;
        }

        .circle-btn:hover {
            background: #e7eaee;
        }

        .btn {
            flex: 1;
            height: 42px;
            border-radius: 10px;
            border: 0;
            cursor: pointer;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: 0.2s;
        }

        .btn.primary {
            background: var(--primary);
            color: #fff;
        }

        .btn.primary:hover {
            background: #1557b0;
        }

        .btn.ghost {
            background: #f3f6fb;
        }

        .btn.ghost:hover {
            background: #e8ecf0;
        }

        .btn.ghost.active {
            background: #e9f1ff;
            color: var(--primary);
            font-weight: 700;
        }

        .btns {
            display: flex;
            gap: 10px;
        }

        /* =============================================================================
           LAYOUT COMPONENTS
        ============================================================================= */
        /* =============================================================================
           LAYOUT COMPONENTS
        ============================================================================= */
        .wrap {
            position: relative;
            width: 100%;
            height: calc(100% - 64px);
            overflow: hidden;
        }

        .sidebar {
            width: 400px;
            max-width: 92vw;
            background: var(--card);
            box-shadow: var(--shadow);
            overflow-y: auto;
            overscroll-behavior: contain;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            z-index: 900;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle {
            position: absolute;
            left: 408px;
            top: 76px;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: var(--card);
            box-shadow: var(--shadow);
            display: grid;
            place-items: center;
            cursor: pointer;
            z-index: 1100;
            border: 1px solid #edf0f4;
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), background 0.2s;
        }

        .toggle:hover {
            background: #f8f9fa;
        }

        .map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #map {
            position: absolute;
            inset: 0;
        }

        /* =============================================================================
           CARD COMPONENTS
        ============================================================================= */
        .card {
            border-bottom: 1px solid #eef0f4;
        }

        .card .head {
            padding: 16px 18px;
            border-bottom: 1px solid #eef0f4;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #fafbff 0%, #f5f7fa 100%);
        }

        .card .body {
            padding: 18px;
        }

        /* =============================================================================
           FORM COMPONENTS
        ============================================================================= */
        .row {
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .label {
            font-size: 13px;
            color: var(--muted);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input {
            position: relative;
        }

        .input input {
            width: 100%;
            height: 42px;
            border: 1px solid #e3e6ea;
            border-radius: 10px;
            padding: 0 42px 0 12px;
            outline: none;
            transition: 0.2s;
        }

        .input input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.08);
        }

        .input .mini {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            color: var(--muted);
            cursor: pointer;
            transition: 0.2s;
        }

        .input .mini:hover {
            color: var(--primary);
        }

        /* =============================================================================
           QUICK ACCESS GRID
        ============================================================================= */
        .quick {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .qbtn {
            padding: 10px;
            border: 1px solid #e3e6ea;
            border-radius: 10px;
            background: #fafbff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: 0.2s;
            font-size: 12px;
            font-weight: 600;
        }

        .qbtn:hover {
            background: #f0f2f7;
            border-color: #d0d5dd;
        }

        /* =============================================================================
           CONTROL COMPONENTS
        ============================================================================= */
        .pair {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #f7f9fc;
            border-radius: 12px;
            margin-bottom: 8px;
        }

        .switch {
            position: relative;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .switch span {
            position: absolute;
            inset: 0;
            border-radius: 999px;
            background: #d9dee3;
            transition: 0.3s;
        }

        .switch span::before {
            content: "";
            position: absolute;
            width: 22px;
            height: 22px;
            left: 3px;
            top: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .switch input:checked+span {
            background: var(--primary);
        }

        .switch input:checked+span::before {
            transform: translateX(22px);
        }

        /* =============================================================================
           STATUS & STATS COMPONENTS
        ============================================================================= */
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #f7f9fc;
            border-radius: 12px;
            margin-top: 10px;
            font-weight: 600;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .stat {
            text-align: center;
            padding: 14px;
            background: #f7f9fc;
            border-radius: 12px;
            transition: 0.2s;
        }

        .stat:hover {
            background: #f0f4f8;
        }

        .stat .val {
            font-weight: 800;
            font-size: 22px;
            color: var(--primary);
        }

        .muted {
            color: var(--muted);
            font-size: 12px;
            font-weight: 600;
        }

        /* =============================================================================
           MAP OVERLAY COMPONENTS
        ============================================================================= */
        .floating {
            position: absolute;
            left: 16px;
            bottom: 16px;
            min-width: 280px;
            background: var(--card);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 14px 16px;
            display: none;
            z-index: 1500;
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .mc {
            position: absolute;
            right: 16px;
            bottom: 120px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1400;
        }

        .mc .cbtn {
            width: 46px;
            height: 46px;
            border-radius: 50%;
            background: var(--card);
            box-shadow: var(--shadow);
            border: 1px solid #edf0f4;
            display: grid;
            place-items: center;
            cursor: pointer;
            transition: 0.2s;
            color: var(--text);
        }

        .mc .cbtn:hover {
            background: #f8f9fa;
            color: var(--primary);
        }

        /* Ensure route box is visible */
        #routeBox {
            z-index: 2000;
            top: 20px;
            right: 20px;
            left: auto;
            bottom: auto;
        }

        .nav-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #202124;
            color: #fff;
            padding: 16px 24px;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 2500;
            display: none;
            width: 90%;
            max-width: 400px;
        }

        .nav-instruction {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .nav-meta {
            font-size: 16px;
            opacity: 0.8;
            display: flex;
            gap: 16px;
        }

        .nav-close {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: grid;
            place-items: center;
            cursor: pointer;
        }

        .nav-header {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            position: absolute;
            top: 16px;
            right: 16px;
        }

        .nav-mute {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
            display: grid;
            place-items: center;
            padding: 0;
        }

        .nav-mute:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .nav-mute.muted i::before {
            content: "\f6a9";
            /* fa-volume-xmark */
        }

        .nav-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
        }

        .nav-progress-bar {
            height: 100%;
            background: #4ade80;
            width: 0%;
            transition: width 0.3s ease-out;
        }


        .type {
            position: absolute;
            right: 16px;
            bottom: 16px;
            background: var(--card);
            border-radius: 14px;
            box-shadow: var(--shadow);
            overflow: hidden;
            z-index: 1450;
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .type .tbtn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-bottom: 1px solid #eef0f4;
            cursor: pointer;
            user-select: none;
            transition: 0.2s;
            font-weight: 600;
        }

        .type .tbtn:last-child {
            border-bottom: 0;
        }

        .type .tbtn:hover {
            background: #f8f9fa;
        }

        .type .tbtn.active {
            background: #e9f1ff;
            color: var(--primary);
            font-weight: 800;
        }

        .recenter {
            position: absolute;
            left: 16px;
            bottom: 86px;
            z-index: 1500;
            display: none;
            background: var(--card);
            border: 1px solid #e3e6ea;
            border-radius: 999px;
            box-shadow: var(--shadow);
            padding: 8px 12px;
            font-weight: 700;
            cursor: pointer;
            transition: 0.2s;
        }

        .recenter:hover {
            background: #f8f9fa;
            color: var(--primary);
        }

        /* =============================================================================
           LOADING & MODAL COMPONENTS
        ============================================================================= */
        .loading {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(6px);
            background: rgba(255, 255, 255, 0.55);
            z-index: 1600;
        }

        .search-spinner {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--primary);
            font-size: 14px;
            display: none;
            /* hidden by default */
            pointer-events: none;
        }

        .spinner {
            width: 58px;
            height: 58px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: var(--primary);
            border-right-color: #34a853;
            animation: spin 1.1s linear infinite;
            position: relative;
        }

        .spinner::after {
            content: "";
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-bottom-color: var(--warning);
            border-left-color: var(--danger);
            animation: spin 1.1s linear infinite reverse;
        }

        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .modal {
            width: min(520px, 92vw);
            background: var(--card);
            border-radius: 14px;
            box-shadow: var(--shadow);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.8);
        }

        .modal .mh {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 14px 16px;
            border-bottom: 1px solid #eef0f4;
            font-weight: 800;
            background: linear-gradient(135deg, #fafbff 0%, #f5f7fa 100%);
        }

        .modal .mb {
            padding: 16px;
        }

        .modal .mf {
            display: flex;
            gap: 10px;
            padding: 14px 16px;
            border-top: 1px solid #eef0f4;
            background: #fafbfc;
        }

        .modal .close {
            background: transparent;
            border: 0;
            font-size: 18px;
            cursor: pointer;
            color: #6b7280;
            transition: 0.2s;
        }

        .modal .close:hover {
            color: var(--danger);
        }

        .modal .input {
            margin-top: 6px;
        }

        .modal .dropdown {
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            max-height: 240px;
            border: 1px solid #edf0f4;
            margin-top: 8px;
        }

        .modal .help {
            font-size: 12px;
            color: var(--muted);
            margin-top: 8px;
        }

        /* =============================================================================
           ALERT/TOAST COMPONENT
        ============================================================================= */
        .alert {
            position: fixed;
            top: 18px;
            right: 18px;
            background: var(--primary);
            color: #fff;
            border-radius: 12px;
            padding: 12px 16px;
            display: none;
            align-items: center;
            gap: 10px;
            box-shadow: var(--shadow);
            z-index: 3000;
            font-weight: 600;
            min-width: 200px;
        }

        .alert.success {
            background: linear-gradient(135deg, #18a566, #0f9d58);
        }

        .alert.error {
            background: linear-gradient(135deg, #ff6b6b, #ea4335);
        }

        .alert.info {
            background: linear-gradient(135deg, #5a8cff, #1a73e8);
        }

        /* =============================================================================
           ANIMATIONS
        ============================================================================= */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.15);
                opacity: 0.75;
            }
        }

        /* =============================================================================
           RESPONSIVE DESIGN
        ============================================================================= */
        @media (max-width: 1024px) {
            .toggle {
                left: 12px;
                top: 74px;
            }

            .sidebar {
                width: 350px;
            }

            .search {
                max-width: 400px;
            }
        }

        @media (max-width: 860px) {
            .wrap {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 48vh;
                border-top-left-radius: 18px;
                border-top-right-radius: 18px;
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 1200;
            }

            .toggle {
                top: auto;
                bottom: 52vh;
            }

            .header {
                padding: 0 12px;
                gap: 12px;
            }

            .search {
                max-width: none;
            }
        }

        @media (max-width: 480px) {
            .header {
                height: 56px;
                padding: 0 8px;
                gap: 8px;
            }

            .logo {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }

            .brand .title {
                font-size: 14px;
            }

            .badge {
                display: none;
            }

            .search input {
                height: 36px;
                font-size: 13px;
            }

            .circle-btn {
                width: 32px;
                height: 32px;
            }

            .sidebar {
                height: 40vh;
            }

            .toggle {
                bottom: 42vh;
                width: 32px;
                height: 32px;
            }
        }

        /* POI Sub-options Styles */
        #poiSubOptions {
            margin-top: 14px;
            background: #f0f7ff;
            border-radius: 12px;
            padding: 14px;
            border: 1px solid #cce0ff;
            display: none;
            animation: slide-down-sub 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slide-down-sub {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .poi-chip {
            background: #fff;
            border: 1px solid #d0d7de;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
            transition: 0.2s;
            user-select: none;
        }

        .poi-chip:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: #f8fbff;
            transform: translateY(-1px);
        }

        .poi-chip.selected {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
            box-shadow: 0 2px 6px rgba(26, 115, 232, 0.3);
        }
    </style>
</head>

<body>
    <!-- =============================================================================
         HEADER SECTION
    ============================================================================= -->
    <header class="header" role="banner">
        <div class="brand" aria-label="Quantum Maps Pro">
            <div class="logo" aria-hidden="true">Q</div>
            <div>
                <div class="title">Quantum Maps Pro</div>
                <div class="badge">
                    <i class="fa-solid fa-atom"></i> Quantum Enhanced
                </div>
            </div>
        </div>

        <div class="search" id="globalSearchWrap">
            <input id="globalSearch" placeholder="Search any place or address…" autocomplete="off"
                aria-label="Global place search" />
            <i class="fa-solid fa-magnifying-glass icon" aria-hidden="true"></i>
            <div class="dropdown" id="globalDropdown" role="listbox"></div>
        </div>

        <div class="actions">
            <button class="circle-btn" id="locBtn" title="Go to my location" aria-label="Go to my location"
                type="button">
                <i class="fa-solid fa-location-crosshairs"></i>
            </button>
            <button class="circle-btn" title="Notifications" aria-label="Notifications" type="button">
                <i class="fa-regular fa-bell"></i>
            </button>
            <button class="circle-btn" title="Layers" aria-label="Layers" type="button">
                <i class="fa-solid fa-layer-group"></i>
            </button>
        </div>
    </header>

    <!-- =============================================================================
         MAIN CONTENT AREA
    ============================================================================= -->
    <div class="wrap">
        <!-- SIDEBAR -->
        <aside class="sidebar" id="sidebar" aria-label="Controls sidebar">
            <!-- DIRECTIONS SECTION -->
            <section class="card">
                <div class="head">
                    <i class="fa-solid fa-route"></i> Directions
                </div>
                <div class="body">
                    <div class="row">
                        <div class="input">
                            <div class="label">
                                <i class="fa-solid fa-location-dot" style="color:var(--success)"></i> From
                            </div>
                            <input id="fromInput" placeholder="Select starting point" autocomplete="off"
                                aria-label="From" />
                            <i class="fa-solid fa-crosshairs mini" id="useMyFrom" title="Use current location"
                                aria-label="Use current location for from"></i>
                            <div class="dropdown" id="fromDropdown"></div>
                        </div>

                        <button class="circle-btn" id="swap" style="align-self:center;" title="Swap" type="button">
                            <i class="fa-solid fa-right-left"></i>
                        </button>

                        <div class="input">
                            <div class="label">
                                <i class="fa-solid fa-flag-checkered" style="color:var(--danger)"></i> To
                            </div>
                            <input id="toInput" placeholder="Select destination" autocomplete="off" aria-label="To" />
                            <i class="fa-solid fa-magnifying-glass mini" aria-hidden="true"></i>
                            <div class="dropdown" id="toDropdown"></div>
                        </div>
                    </div>

                    <div class="row" style="margin-top:8px;">
                        <div class="label">
                            <i class="fa-solid fa-person-walking"></i> Transport Mode
                        </div>
                        <div class="btns">
                            <button class="btn ghost" data-mode="driving" id="modeDriving" aria-pressed="true"
                                type="button">
                                <i class="fa-solid fa-car"></i> Driving
                            </button>
                            <button class="btn ghost" data-mode="cycling" id="modeCycling" type="button">
                                <i class="fa-solid fa-bicycle"></i> Cycling
                            </button>
                            <button class="btn ghost" data-mode="walking" id="modeWalking" type="button">
                                <i class="fa-solid fa-person-walking"></i> Walking
                            </button>
                        </div>
                    </div>

                    <div class="btns" style="margin-top:12px;">
                        <button class="btn primary" id="routeBtn" type="button">
                            <i class="fa-solid fa-directions"></i> Get Directions
                        </button>
                        <button class="btn ghost" id="clearBtn" type="button">
                            <i class="fa-solid fa-xmark"></i> Clear
                        </button>
                    </div>

                    <!-- VEHICLE FIT ANALYSIS SECTION - MOVED HERE UNDER GET DIRECTION -->
                    <div style="margin-top:16px; padding-top:16px; border-top: 1px solid #eef0f4;">
                        <div class="label" style="margin-bottom:12px;">
                            <i class="fa-solid fa-truck"></i> Vehicle Fit Analysis
                        </div>

                        <div class="input" style="margin-bottom:12px;">
                            <div class="label" style="font-size:12px;">
                                <i class="fa-solid fa-truck-front"></i> Vehicle Type
                            </div>
                            <select id="vehicleType"
                                style="width:100%;height:38px;border:1px solid #e3e6ea;border-radius:8px;padding:0 12px;font-size:14px;">
                                <option value="car">Car</option>
                                <option value="truck">Truck</option>
                                <option value="van">Van</option>
                                <option value="bus">Bus</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>

                        <div id="vehicleSelectContainer" style="margin-bottom:12px;">
                            <div class="label" style="font-size:12px;">
                                <i class="fa-solid fa-car"></i> Select Vehicle
                            </div>
                            <select id="vehicleSelect"
                                style="width:100%;height:38px;border:1px solid #e3e6ea;border-radius:8px;padding:0 12px;font-size:14px;">
                                <option value="Toyota|Camry|2023">Toyota Camry (2023)</option>
                                <option value="Ford|F-150|2023">Ford F-150 (2023)</option>
                                <option value="Honda|CR-V|2023">Honda CR-V (2023)</option>
                                <option value="Tesla|Model 3|2023">Tesla Model 3 (2023)</option>
                                <option value="BMW|X5|2023">BMW X5 (2023)</option>
                                <option value="Mercedes|Sprinter|2023">Mercedes Sprinter (2023)</option>
                                <option value="Chevrolet|Tahoe|2023">Chevrolet Tahoe (2023)</option>
                                <option value="Volkswagen|Golf|2023">Volkswagen Golf (2023)</option>
                                <option value="Dodge|RAM 2500|2023">Dodge RAM 2500 (2023)</option>
                                <option value="Toyota|Sienna|2023">Toyota Sienna (2023)</option>
                            </select>
                        </div>

                        <div id="customVehicle" style="display:none;">
                            <div class="row">
                                <div class="input">
                                    <div class="label" style="font-size:12px;">
                                        <i class="fa-solid fa-ruler-horizontal"></i> Width (m)
                                    </div>
                                    <input id="vehicleWidth" type="number" placeholder="2.5" step="0.1" min="1.0"
                                        max="5.0" value="2.5" />
                                </div>
                                <div class="input">
                                    <div class="label" style="font-size:12px;">
                                        <i class="fa-solid fa-ruler-vertical"></i> Height (m)
                                    </div>
                                    <input id="vehicleHeight" type="number" placeholder="3.5" step="0.1" min="1.5"
                                        max="6.0" value="3.5" />
                                </div>
                            </div>

                            <div class="row" style="margin-top:8px;">
                                <div class="input">
                                    <div class="label" style="font-size:12px;">
                                        <i class="fa-solid fa-weight-hanging"></i> Weight (tons)
                                    </div>
                                    <input id="vehicleWeight" type="number" placeholder="12" step="0.5" min="1.0"
                                        max="50.0" value="12" />
                                </div>
                                <div class="input">
                                    <div class="label" style="font-size:12px;">
                                        <i class="fa-solid fa-truck-front"></i> Length (m)
                                    </div>
                                    <input id="vehicleLength" type="number" placeholder="12" step="0.5" min="3.0"
                                        max="25.0" value="12" />
                                </div>
                            </div>
                        </div>

                        <div class="btns" style="margin-top:12px;">
                            <button class="btn primary" id="analyzeVehicleFit" style="font-size:13px;">
                                <i class="fa-solid fa-magnifying-glass"></i> Analyze Fit
                            </button>
                            <button class="btn ghost" id="clearVehicleAnalysis" style="font-size:13px;">
                                <i class="fa-solid fa-xmark"></i> Clear
                            </button>
                        </div>

                        <!-- Analysis Results -->
                        <div id="vehicleAnalysisResults" style="display:none; margin-top:16px;">
                            <div class="status" id="fitStatus" style="background:#f0f4f8;">
                                <span class="dot"></span>
                                <span id="fitStatusText" style="font-size:13px;">Ready to analyze</span>
                            </div>

                            <div id="fitDetails" style="margin-top:12px; font-size:12px; display:none;">
                                <div style="display:grid; grid-template-columns:auto 1fr; gap:6px 10px;">
                                    <div class="muted">Road Width:</div>
                                    <div id="roadWidth">—</div>
                                    <div class="muted">Bridge Height:</div>
                                    <div id="bridgeHeight">—</div>
                                    <div class="muted">Weight Limit:</div>
                                    <div id="weightLimit">—</div>
                                    <div class="muted">Turn Radius:</div>
                                    <div id="turnRadius">—</div>
                                </div>
                            </div>

                            <!-- Alternative Routes Section -->
                            <div id="alternativeRouteSection" style="display:none; margin-top:12px;">
                                <div id="alternativeRoutesAvailable" style="display:none;">
                                    <div
                                        style="color:var(--primary); font-size:13px; margin-bottom:8px; font-weight:600;">
                                        <i class="fa-solid fa-route"></i> <span id="routeCountText">3 alternative routes
                                            available</span>
                                    </div>
                                    <div id="routeOptions"
                                        style="display:flex; flex-direction:column; gap:6px; margin-bottom:8px;">
                                        <!-- Route option buttons will be dynamically added here -->
                                    </div>
                                </div>
                                <div id="noAlternativeRoutes" style="display:none;">
                                    <div
                                        style="color:var(--muted); font-size:13px; margin-bottom:8px; padding:10px; background:#f8f9fa; border-radius:8px; text-align:center;">
                                        <i class="fa-solid fa-triangle-exclamation"></i> No alternative routes available
                                        for this vehicle
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- QUICK ACCESS BUTTONS -->
                    <div class="quick" style="margin-top:14px;">
                        <button class="qbtn" data-type="fuel">
                            <i class="fa-solid fa-gas-pump"></i> Gas
                        </button>
                        <button class="qbtn" data-type="restaurant">
                            <i class="fa-solid fa-utensils"></i> Food
                        </button>
                        <button class="qbtn" data-type="hotel">
                            <i class="fa-solid fa-bed"></i> Hotels
                        </button>
                        <button class="qbtn" data-type="hospital">
                            <i class="fa-solid fa-hospital"></i> Medical
                        </button>
                        <button class="qbtn" data-type="atm">
                            <i class="fa-solid fa-money-bill-wave"></i> ATMs
                        </button>
                        <button class="qbtn" data-type="park">
                            <i class="fa-solid fa-tree"></i> Parks
                        </button>
                    </div>

                    <!-- POI SUB-OPTIONS PANEL -->
                    <div id="poiSubOptions">
                        <div id="poiQuestion" class="label" style="font-size:13px; margin-bottom:10px; color:#0056b3;">
                            What are you looking for?
                        </div>
                        <div id="poiOptions" style="display:flex; flex-wrap:wrap; gap:8px;">
                            <!-- Options will be injected here -->
                        </div>
                    </div>

                    <div class="btns" style="margin-top:12px;">
                        <button class="btn ghost" id="addWpBtn">
                            <i class="fa-solid fa-map-pin"></i> Add Waypoint
                        </button>
                    </div>
                </div>
            </section>

            <!-- QUANTUM CONTROLS SECTION -->
            <section class="card">
                <div class="head">
                    <i class="fa-solid fa-sliders"></i> Quantum Controls
                </div>
                <div class="body">
                    <div class="pair">
                        <span><i class="fa-solid fa-atom"></i> Quantum Optimization</span>
                        <label class="switch">
                            <input type="checkbox" id="qOpt" checked />
                            <span></span>
                        </label>
                    </div>
                    <div class="pair">
                        <span><i class="fa-solid fa-wave-square"></i> Superposition Mode</span>
                        <label class="switch">
                            <input type="checkbox" id="qSuper" />
                            <span></span>
                        </label>
                    </div>
                    <div class="pair">
                        <span><i class="fa-solid fa-traffic-light"></i> Quantum Traffic</span>
                        <label class="switch">
                            <input type="checkbox" id="qTraffic" checked />
                            <span></span>
                        </label>
                    </div>
                    <div class="pair">
                        <span><i class="fa-solid fa-person-chalkboard"></i> Live Tracking</span>
                        <label class="switch">
                            <input type="checkbox" id="liveTrack" />
                            <span></span>
                        </label>
                    </div>
                    <div class="status">
                        <span class="dot"></span>
                        <span id="status">Quantum Systems Online</span>
                    </div>
                </div>
            </section>

            <!-- NAVIGATION STATS SECTION -->
            <section class="card">
                <div class="head">
                    <i class="fa-solid fa-chart-column"></i> Navigation Stats
                </div>
                <div class="input-group">
                    <label>From</label>
                    <div class="input-wrapper" style="position:relative;">
                        <input type="text" id="fromInput" placeholder="Current Location">
                        <i class="fa-solid fa-spinner fa-spin search-spinner" id="fromSpinner"></i>
                    </div>
                </div>
                <div class="input-group">
                    <label>To</label>
                    <div class="input-wrapper" style="position:relative;">
                        <input type="text" id="toInput" placeholder="Enter destination">
                        <i class="fa-solid fa-spinner fa-spin search-spinner" id="toSpinner"></i>
                    </div>
                </div>
                <div class="body">
                    <div class="stats">
                        <div class="stat">
                            <div class="val" id="wayCount">0</div>
                            <div class="muted">Waypoints</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="mode">Quantum</div>
                            <div class="muted">Mode</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="navDist">—</div>
                            <div class="muted">Distance</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="navEta">—</div>
                            <div class="muted">ETA</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="navAlgo">—</div>
                            <div class="muted">Algorithm</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="navOpt">—</div>
                            <div class="muted">Optimization</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="distSave">—</div>
                            <div class="muted">Distance Saved</div>
                        </div>
                        <div class="stat">
                            <div class="val" id="timeSave">—</div>
                            <div class="muted">Time Saved</div>
                        </div>
                    </div>
                </div>
            </section>
        </aside>

        <!-- TOGGLE BUTTON -->
        <button class="toggle" id="toggle" title="Toggle sidebar" aria-label="Toggle sidebar">
            <i class="fa-solid fa-chevron-left"></i>
        </button>

        <!-- MAP SECTION -->
        <main class="map" aria-label="Map">
            <div id="map" role="application" aria-label="Map canvas"></div>

            <!-- MAP CONTROLS -->
            <button class="recenter" id="recenterBtn">
                <i class="fa-solid fa-location-arrow"></i> Re-center
            </button>

            <!-- ROUTE INFORMATION BOX -->
            <div class="floating" id="routeBox">
                <div style="font-weight:800;display:flex;align-items:center;gap:8px;margin-bottom:8px;">
                    <i class="fa-solid fa-route"></i> Route Analysis
                </div>
                <div style="display:grid;grid-template-columns:auto 1fr;gap:6px 14px;font-weight:700;">
                    <div class="muted">Distance</div>
                    <div id="rDist">—</div>
                    <div class="muted">ETA</div>
                    <div id="rEta">—</div>
                    <div class="muted">Algorithm</div>
                    <div id="rAlgo">—</div>
                    <div class="muted">Optimization</div>
                    <div id="rOpt">—</div>
                </div>
                <button class="btn primary" id="startNavBtn" style="margin-top:12px;width:100%;"
                    onclick="window.quantumMaps.startNavigation()">
                    <i class="fa-solid fa-location-arrow"></i> Start My Ride
                </button>
            </div>

            <!-- NAVIGATION OVERLAY -->
            <div class="nav-overlay" id="navOverlay">
                <div class="nav-header">
                    <button class="nav-mute" id="navMute" onclick="window.quantumMaps.toggleMute()">
                        <i class="fa-solid fa-volume-high" id="muteIcon"></i>
                    </button>
                    <div class="nav-close" onclick="window.quantumMaps.stopNavigation()">
                        <i class="fa-solid fa-xmark"></i>
                    </div>
                </div>

                <div class="nav-instruction" id="navText">
                    <i class="fa-solid fa-arrow-up" id="turnIcon"></i>
                    <span id="instructionText">Head North</span>
                </div>

                <div class="nav-meta">
                    <span id="navNextDist">200 m</span>
                    <span id="navSpeed">-- km/h</span>
                    <span id="navETA">12 min</span>
                </div>

                <div class="nav-progress">
                    <div class="nav-progress-bar" id="navProgressBar"></div>
                </div>
            </div>

            <!-- MAP CONTROL BUTTONS -->
            <div class="mc">
                <button class="cbtn" id="zin" title="Zoom in">
                    <i class="fa-solid fa-plus"></i>
                </button>
                <button class="cbtn" id="zout" title="Zoom out">
                    <i class="fa-solid fa-minus"></i>
                </button>
                <button class="cbtn" id="goto" title="Go to my location">
                    <i class="fa-solid fa-location-arrow"></i>
                </button>
            </div>

            <!-- MAP TYPE SELECTOR -->
            <div class="type" role="tablist" aria-label="Basemap types">
                <div class="tbtn active" data-type="roadmap" role="tab">
                    <i class="fa-solid fa-map"></i> Default
                </div>
                <div class="tbtn" data-type="satellite" role="tab">
                    <i class="fa-solid fa-satellite"></i> Satellite
                </div>

            </div>

            <!-- LOADING SPINNER -->
            <div class="loading" id="loading">
                <div class="spinner" aria-label="Loading"></div>
            </div>
        </main>
    </div>

    <!-- =============================================================================
         MODALS & OVERLAYS
    ============================================================================= -->
    <!-- WAYPOINT MODAL -->
    <div class="modal-backdrop" id="wpModalBackdrop" role="dialog" aria-modal="true" aria-labelledby="wpModalTitle">
        <div class="modal">
            <div class="mh">
                <div id="wpModalTitle">
                    <i class="fa-solid fa-map-pin"></i> Add Waypoint
                </div>
                <button class="close" id="wpModalClose" aria-label="Close">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <div class="mb">
                <div class="label">
                    <i class="fa-solid fa-magnifying-glass"></i> Address or Place
                </div>
                <div class="input">
                    <input id="wpSearchInput" placeholder="Type an address or place…" autocomplete="off"
                        aria-label="Waypoint address" />
                    <div class="dropdown" id="wpDropdown" role="listbox"></div>
                </div>
                <div class="help">Pick a result to add it as a numbered waypoint on the map.</div>
            </div>
            <div class="mf">
                <button class="btn ghost" id="wpCancel">
                    <i class="fa-solid fa-ban"></i> Cancel
                </button>
                <button class="btn primary" id="wpAdd" disabled>
                    <i class="fa-solid fa-plus"></i> Add Waypoint
                </button>
            </div>
        </div>
    </div>

    <!-- TOAST NOTIFICATIONS -->
    <div class="alert" id="toast">
        <i class="fa-solid fa-circle-info"></i>
        <span id="toastMsg">Hello</span>
    </div>

    <!-- =============================================================================
         EXTERNAL SCRIPTS
    ============================================================================= -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        /* =============================================================================
           CONFIGURATION & CONSTANTS
        ============================================================================= */
        const CONFIG = {
            // ⚠️ DEPLOYMENT: Replace YOUR-BACKEND-NAME with your actual Render service name
            BACKEND_URL: 'https://YOUR-BACKEND-NAME.onrender.com/quantum_route',
            USE_BACKEND: true,

            // Map settings
            DEFAULT_ZOOM: 13,
            MIN_ZOOM: 2,
            MAX_ZOOM: 19,

            // Search settings
            MIN_SEARCH_CHARS: 3,
            MAX_SEARCH_RESULTS: 6,

            // Vehicle analysis settings
            VEHICLE_ANALYSIS_URL: 'https://YOUR-BACKEND-NAME.onrender.com/analyze_vehicle_fit',
            ALTERNATIVE_ROUTE_URL: 'https://YOUR-BACKEND-NAME.onrender.com/generate_alternative_route',
            // Optimized Search Settings
            SEARCH_DEBOUNCE_MS: 350,   // Increased from 280ms to reduce API calls
            SEARCH_CACHE_TTL: 300000,  // 5 minutes cache validity

            // Geolocation settings
            GEOLOCATION_TIMEOUT: 10000,
            GEOLOCATION_MAX_AGE: 0,
            WATCH_TIMEOUT: 15000,
            WATCH_MAX_AGE: 2000,

            // Nearby search settings
            NEARBY_RADIUS: 1500,
            MAX_NEARBY_RESULTS: 10,

            // Animation settings
            TOAST_DURATION: 3500,
            SLEEP_BETWEEN_REQUESTS: 80,

            // Default fallback location (London)
            DEFAULT_LOCATION: {
                lat: 51.505,
                lng: -0.09,
                name: 'London, UK'
            },

            // OpenRouteService API
            ORS_API_KEY: '5b3ce3597851110001cf6248fa0bf4e55e2e4b4ebad56b3b4e67df0f', // Get your free key from openrouteservice.org
            ORS_BASE_URL: 'https://api.openrouteservice.org/v2'
        };

        const POI_CONFIG = {
            hotel: {
                steps: [
                    { id: 'type', question: "What are you looking for?", options: ['Accommodation', 'Restaurant'] },
                    { id: 'cuisine', question: "Cuisine Preference?", options: ['Veg', 'Non-Veg', 'Any'], condition: (answers) => answers.type === 'Restaurant' },
                    { id: 'stay_type', question: "Stay Type?", options: ['Budget', 'Luxury', 'Resort'], condition: (answers) => answers.type === 'Accommodation' },
                    { id: 'meal', question: "Meal Type?", options: ['Breakfast', 'Lunch', 'Dinner'], condition: (answers) => answers.type === 'Restaurant' }
                ]
            },
            restaurant: {
                steps: [
                    { id: 'cuisine', question: "Cuisine Preference?", options: ['Veg', 'Non-Veg', 'Any'] },
                    { id: 'meal', question: "Meal Type?", options: ['Breakfast', 'Lunch', 'Dinner'] }
                ]
            },
            fuel: {
                steps: [
                    { id: 'fuel_type', question: "Fuel Type?", options: ['Petrol', 'Diesel', 'Electric', 'CNG'] }
                ]
            },
            park: {
                steps: [
                    { id: 'park_type', question: "Park Type?", options: ['Public Park', 'National Park', 'Playground'] }
                ]
            },
            hospital: {
                steps: [
                    { id: 'care_type', question: "Type of Care?", options: ['General', 'Emergency', 'Dental', 'Eye'] }
                ]
            },
            atm: {
                steps: [
                    { id: 'service_type', question: "Service Type?", options: ['Debit', 'Credit', 'RBI Office', 'Banks'] }
                ]
            }
        };

        const POI_TAGS = {
            fuel: 'amenity=fuel',
            restaurant: 'amenity=restaurant',
            hotel: 'tourism=hotel',
            hospital: 'amenity=hospital',
            atm: 'amenity=atm',
            park: 'leisure=park',
            bank: 'amenity=bank'
        };

        const TRANSPORT_MODES = {
            walking: { avgSpeedKmh: 5, trafficFactor: 1.0, osrmProfile: 'foot', orsProfile: 'foot-walking' },
            cycling: { avgSpeedKmh: 15, trafficFactor: 1.05, osrmProfile: 'bike', orsProfile: 'cycling-regular' },
            driving: { avgSpeedKmh: 38, trafficFactor: 1.25, osrmProfile: 'driving', orsProfile: 'driving-car' }
        };

        const COLORS = {
            quantum: '#1a73e8',
            superposition: '#8e67ff',
            classical: '#ea4335',
            success: '#18a566',
            danger: '#ea4335',
            warning: '#fbbc05',
            waypoint: '#fbbc05',
            alternative1: '#9c27b0',
            alternative2: '#ff9800',
            alternative3: '#00bcd4'
        };

        // Vehicle dimensions database
        const VEHICLE_DIMENSIONS = {
            sedan: { width: 1.8, height: 1.4, length: 4.5, weight: 1.5 },
            suv: { width: 2.0, height: 1.8, length: 4.8, weight: 2.0 },
            pickup: { width: 2.1, height: 1.9, length: 5.2, weight: 2.2 },
            van: { width: 2.2, height: 2.4, length: 5.5, weight: 2.5 },
            box_truck: { width: 2.5, height: 3.2, length: 7.0, weight: 7.5 },
            semi_truck: { width: 2.6, height: 4.0, length: 16.0, weight: 15.0 },
            bus: { width: 2.5, height: 3.2, length: 12.0, weight: 12.0 }
        };

        /* =============================================================================
           UTILITY FUNCTIONS
        ============================================================================= */
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const deg2rad = (degrees) => degrees * Math.PI / 180;

        const haversineKm = (pointA, pointB) => {
            const R = 6371;
            const dLat = deg2rad(pointB.lat - pointA.lat);
            const dLng = deg2rad(pointB.lng - pointA.lng);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(pointA.lat)) * Math.cos(deg2rad(pointB.lat)) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);

            return 2 * R * Math.asin(Math.sqrt(a));
        };

        const debounce = (fn, delay = 300) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn(...args), delay);
            };
        };

        const clamp = (num, min, max) => Math.max(min, Math.min(max, num));

        const getElement = (id) => {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with ID '${id}' not found`);
            }
            return element;
        };

        const formatDistance = (km) => {
            if (km < 1) return `${Math.round(km * 1000)} m`;
            return `${km.toFixed(2)} km`;
        };

        const formatDuration = (minutes) => {
            if (minutes < 60) return `${Math.round(minutes)} min`;
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            return `${hours}h ${mins}m`;
        };

        const isValidCoordinate = (lat, lng) => {
            return typeof lat === 'number' && typeof lng === 'number' &&
                lat >= -90 && lat <= 90 &&
                lng >= -180 && lng <= 180;
        };

        const generateId = () => {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        };

        /* =============================================================================
           QUANTUM MAPS MAIN CLASS
        ============================================================================= */
        class QuantumMaps {
            constructor() {
                // Map properties
                this.map = null;
                this.base = { roadmap: null, satellite: null };
                this.currentType = 'roadmap';

                // POI Sub-options State
                this.poiAnswers = {};
                this.currentPOIType = null;
                this.currentPOIStep = 0;

                // Markers and overlays
                this.fromMarker = null;
                this.toMarker = null;
                this.places = [];
                this.routeLine = null;

                // Cache for search results
                this.searchCache = new Map();
                this.alternativeRoutes = [];
                this.alternativeRouteLines = [];

                // User location tracking
                this.user = CONFIG.DEFAULT_LOCATION;
                this.userMarker = null;
                this.userCircle = null;
                this.watchId = null;
                this.follow = false;
                this.locationDetected = false;

                // Settings
                this.qOpt = true;
                this.qSuper = false;
                this.qTraffic = true;
                this.transport = 'driving';
                this.wpSelected = null;

                // Vehicle analysis
                this.vehicleAnalysisShown = false; // Prevents repeated dialogs
                this.currentFitAnalysis = null;

                // Initialize application
                this.init();
            }

            /* =========================================================================
               INITIALIZATION METHODS
            ========================================================================= */
            init() {
                this.initMap();
                this.wireUI();
                this.detectLocationOnce();
                this.toast('Quantum navigation initialized', 'success');
                this.updateMode();
            }

            initMap() {
                this.map = L.map('map', { zoomControl: false }).setView([CONFIG.DEFAULT_LOCATION.lat, CONFIG.DEFAULT_LOCATION.lng], CONFIG.DEFAULT_ZOOM);

                this.base.roadmap = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                    maxZoom: 21,
                    subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                    attribution: '&copy; Google Maps'
                }).addTo(this.map);

                this.base.satellite = L.tileLayer('http://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                    maxZoom: 21,
                    subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                    attribution: '&copy; Google Maps'
                });

                getElement('zin').onclick = () => this.map.zoomIn();
                getElement('zout').onclick = () => this.map.zoomOut();

                this.map.on('click', (e) => this.addWaypoint(e.latlng));

                const stopFollow = () => {
                    if (this.follow) {
                        this.follow = false;
                        getElement('recenterBtn').style.display = 'inline-flex';
                    }
                };

                this.map.on('dragstart', stopFollow);
                this.map.on('zoomstart', stopFollow);
            }

            wireUI() {
                const sidebar = getElement('sidebar');
                const toggle = getElement('toggle');

                if (sidebar && toggle) {
                    toggle.onclick = () => {
                        // Unified Overlay Logic (Desktop & Mobile)
                        const isHidden = sidebar.style.transform === 'translateX(-110%)';
                        sidebar.style.transform = isHidden ? 'translateX(0)' : 'translateX(-110%)';

                        // Toggle button follows the sidebar edge
                        // Desktop default: 408px vs 12px
                        // Mobile default: handled by media queries, but we can animate left if needed
                        if (window.innerWidth >= 860) {
                            toggle.style.left = isHidden ? '408px' : '12px';
                        } else {
                            // Mobile toggle positioning is often different (bottom sheet?).
                            // But if we use 'left' transition, it might work.
                            // Current CSS says .toggle is left:12px on mobile (max-width 1024).
                            // If mobile sidebar hides, button should stay visible?
                            // Mobile sidebar is often bottom-sheet or full-screen.
                            // Let's rely on CSS for mobile unless user reports issue.
                            // For now, only animate 'left' on desktop.
                        }

                        toggle.innerHTML = isHidden ?
                            '<i class="fa-solid fa-chevron-left"></i>' :
                            '<i class="fa-solid fa-chevron-right"></i>';
                    };
                }

                if (window.innerWidth < 860 && sidebar) {
                    sidebar.style.transform = 'translateX(0)';
                }

                document.querySelectorAll('.tbtn').forEach(btn => {
                    btn.onclick = () => this.changeType(btn.dataset.type);
                });

                const safeClick = (id, fn) => {
                    const el = getElement(id);
                    if (el) el.onclick = fn;
                };

                safeClick('goto', () => this.goToUser(true));
                safeClick('locBtn', () => this.goToUser(true));
                safeClick('useMyFrom', () => this.useCurrentAsFrom());
                safeClick('routeBtn', () => this.buildRoute());
                safeClick('clearBtn', () => this.clearAll());
                safeClick('swap', () => this.swapFT());

                const safeChange = (id, fn) => {
                    const el = getElement(id);
                    if (el) el.onchange = fn;
                };

                safeChange('qOpt', (e) => {
                    this.qOpt = e.target.checked;
                    this.updateMode();
                });
                safeChange('qSuper', (e) => {
                    this.qSuper = e.target.checked;
                    this.updateMode();
                });
                safeChange('qTraffic', (e) => {
                    this.qTraffic = e.target.checked;
                    this.updateMode();
                });

                const transportButtons = [
                    getElement('modeDriving'),
                    getElement('modeCycling'),
                    getElement('modeWalking')
                ];

                transportButtons.forEach(btn => {
                    if (btn) {
                        btn.onclick = () => {
                            transportButtons.forEach(b => b && b.classList.remove('active'));
                            btn.classList.add('active');
                            this.transport = btn.dataset.mode;
                            this.toast(`Mode: ${this.transport}`, 'info');
                        };
                    }
                });

                if (getElement('modeDriving')) getElement('modeDriving').classList.add('active');

                safeChange('liveTrack', (e) => {
                    e.target.checked ? this.startLiveTracking() : this.stopLiveTracking();
                });

                safeClick('recenterBtn', () => {
                    this.follow = true;
                    if (getElement('recenterBtn')) getElement('recenterBtn').style.display = 'none';
                    if (this.user) this.map.setView([this.user.lat, this.user.lng], clamp(this.map.getZoom(), 14, 18), { animate: true });
                });

                this.bindAutocomplete(getElement('fromInput'), getElement('fromDropdown'), (sel) => this.setFrom(sel));
                this.bindAutocomplete(getElement('toInput'), getElement('toDropdown'), (sel) => this.setTo(sel));
                this.bindAutocomplete(getElement('globalSearch'), getElement('globalDropdown'), (sel) => {
                    this.map.setView([sel.lat, sel.lng], 15);
                    this.addWaypoint(sel);
                });

                document.querySelectorAll('.qbtn').forEach(btn => {
                    btn.onclick = () => this.startPOIFlow(btn.dataset.type);
                });

                safeClick('addWpBtn', () => this.openWpModal());
                safeClick('wpModalClose', () => this.closeWpModal());
                safeClick('wpCancel', () => this.closeWpModal());
                safeClick('wpAdd', () => this.confirmAddWaypoint());

                this.bindAutocomplete(getElement('wpSearchInput'), getElement('wpDropdown'), (sel) => {
                    this.wpSelected = sel;
                    const wpAdd = getElement('wpAdd');
                    if (wpAdd) wpAdd.disabled = false;
                }, 3, 8);

                safeClick('analyzeVehicleFit', () => {
                    if (!this.fromMarker || !this.toMarker) {
                        this.toast('Please create a route first', 'error');
                        return;
                    }
                    this.analyzeVehicleFit();
                });

                safeClick('clearVehicleAnalysis', () => {
                    this.clearVehicleAnalysis();
                });

                safeChange('vehicleType', (e) => {
                    const customVehicle = getElement('customVehicle');
                    const vehicleSelect = getElement('vehicleSelectContainer');
                    if (!customVehicle || !vehicleSelect) return;

                    if (e.target.value === 'custom') {
                        customVehicle.style.display = 'block';
                        vehicleSelect.style.display = 'none';
                    } else {
                        customVehicle.style.display = 'none';
                        vehicleSelect.style.display = 'block';
                    }
                });
            }

            /* =========================================================================
               GEOLOCATION METHODS
            ========================================================================= */
            detectLocationOnce() {
                if (!navigator.geolocation) {
                    this.status('Using default location — London');
                    this.toast('Geolocation not supported, using London as default', 'info');
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        this.updateUserPosition(pos);
                        this.locationDetected = true;
                        this.map.setView([pos.coords.latitude, pos.coords.longitude], 15);
                        this.status('Current location detected');
                        this.toast('Location detected successfully', 'success');
                    },
                    (error) => {
                        console.warn('Geolocation error:', error);
                        let errorMsg = 'Location access denied';

                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = 'Location access denied by user';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = 'Location information unavailable';
                                break;
                            case error.TIMEOUT:
                                errorMsg = 'Location request timed out';
                                break;
                        }

                        this.status('Using default location — London');
                        this.toast(errorMsg + ', using London as default', 'info');

                        this.updateUserPosition({
                            coords: {
                                latitude: CONFIG.DEFAULT_LOCATION.lat,
                                longitude: CONFIG.DEFAULT_LOCATION.lng,
                                accuracy: 1000,
                                heading: null
                            }
                        });
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: CONFIG.GEOLOCATION_TIMEOUT,
                        maximumAge: CONFIG.GEOLOCATION_MAX_AGE
                    }
                );
            }

            startLiveTracking() {
                if (!navigator.geolocation) {
                    this.toast('Geolocation not supported', 'error');
                    getElement('liveTrack').checked = false;
                    return;
                }

                if (this.watchId !== null) return;

                this.follow = true;
                getElement('recenterBtn').style.display = 'none';
                this.status('Live tracking enabled');

                this.watchId = navigator.geolocation.watchPosition(
                    (pos) => this.handleWatchUpdate(pos),
                    (err) => {
                        this.toast(`Live tracking error: ${err.message}`, 'error');
                        this.stopLiveTracking();
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: CONFIG.WATCH_TIMEOUT,
                        maximumAge: CONFIG.WATCH_MAX_AGE
                    }
                );
            }

            stopLiveTracking() {
                if (this.watchId !== null) {
                    navigator.geolocation.clearWatch(this.watchId);
                    this.watchId = null;
                }
                this.follow = false;
                this.status('Live tracking disabled');
                getElement('recenterBtn').style.display = 'none';
            }

            handleWatchUpdate(pos) {
                this.updateUserPosition(pos);
                this.locationDetected = true;
                if (this.follow && this.user) {
                    const targetZoom = clamp(this.map.getZoom(), 14, 18);
                    this.map.setView([this.user.lat, this.user.lng], targetZoom, { animate: true });
                }
            }

            updateUserPosition(pos) {
                const { latitude, longitude, accuracy, heading } = pos.coords;
                this.user = {
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy || 25,
                    heading: heading || null
                };

                if (!this.userMarker) {
                    const html = `
                        <div style="position:relative;width:18px;height:18px;">
                            <div style="width:18px;height:18px;border-radius:50%;background:#1a73e8;border:3px solid #fff;box-shadow:0 4px 14px rgba(26,115,232,.6);"></div>
                            <div id="headingTip" style="position:absolute;left:50%;top:-10px;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-bottom:10px solid #1a73e8;transform:translateX(-50%) rotate(0deg);display:${this.user.heading !== null ? 'block' : 'none'};"></div>
                        </div>
                    `;

                    const userIcon = L.divIcon({
                        className: 'user-dot',
                        iconSize: [18, 18],
                        iconAnchor: [9, 9],
                        html: html
                    });

                    this.userMarker = L.marker([latitude, longitude], { icon: userIcon }).addTo(this.map);
                    this.userCircle = L.circle([latitude, longitude], {
                        radius: this.user.accuracy,
                        color: '#1a73e8',
                        fillColor: '#1a73e8',
                        fillOpacity: 0.12,
                        weight: 1
                    }).addTo(this.map);
                } else {
                    this.userMarker.setLatLng([latitude, longitude]);
                    this.userCircle.setLatLng([latitude, longitude]);
                    this.userCircle.setRadius(this.user.accuracy);

                    const tip = this.userMarker._icon?.querySelector('#headingTip');
                    if (tip) {
                        if (this.user.heading !== null && !Number.isNaN(this.user.heading)) {
                            tip.style.display = 'block';
                            tip.style.transform = `translateX(-50%) rotate(${this.user.heading}deg)`;
                        } else {
                            tip.style.display = 'none';
                        }
                    }
                }
            }

            /* =========================================================================
               MAP CONTROL METHODS
            ========================================================================= */
            changeType(type) {
                if (this.currentType === type) return;

                Object.values(this.base).forEach(layer => {
                    if (this.map.hasLayer(layer)) this.map.removeLayer(layer);
                });

                this.base[type].addTo(this.map);
                this.currentType = type;

                document.querySelectorAll('.tbtn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.type === type);
                });
            }

            /* =========================================================================
               AUTOCOMPLETE & SEARCH METHODS
            ========================================================================= */
            bindAutocomplete(input, dropdown, onSelect, minChars = 3, maxItems = 6) {
                // Identify the correct spinner based on input ID
                const spinnerId = input.id === 'fromInput' ? 'fromSpinner' :
                    input.id === 'toInput' ? 'toSpinner' : null;
                const spinner = spinnerId ? document.getElementById(spinnerId) : null;

                const doSearch = debounce(async (query) => {
                    if (query.length < minChars) {
                        dropdown.style.display = 'none';
                        return;
                    }

                    // 1. Check Cache
                    const cacheKey = query.toLowerCase();
                    if (this.searchCache.has(cacheKey)) {
                        const cached = this.searchCache.get(cacheKey);
                        if (Date.now() - cached.time < CONFIG.SEARCH_CACHE_TTL) {
                            // Use cached results
                            this.renderDropdown(cached.data, dropdown, input, onSelect);
                            return;
                        }
                    }

                    // 2. Show Loading
                    if (spinner) spinner.style.display = 'block';

                    try {
                        const response = await fetch(
                            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=${maxItems}`
                        );
                        if (!response.ok) throw new Error('Search failed');

                        const data = await response.json();

                        // 3. Update Cache
                        this.searchCache.set(cacheKey, {
                            time: Date.now(),
                            data: data
                        });

                        // 4. Render Results
                        this.renderDropdown(data, dropdown, input, onSelect);

                    } catch (error) {
                        console.warn('Search error:', error);
                        dropdown.style.display = 'none';
                    } finally {
                        // 5. Hide Loading
                        if (spinner) spinner.style.display = 'none';
                    }
                }, CONFIG.SEARCH_DEBOUNCE_MS);

                input.addEventListener('input', (e) => doSearch(e.target.value.trim()));

                document.addEventListener('click', (evt) => {
                    if (!dropdown.contains(evt.target) && evt.target !== input) {
                        dropdown.style.display = 'none';
                    }
                });
            }

            // Helper to render dropdown items
            renderDropdown(data, dropdown, input, onSelect) {
                dropdown.innerHTML = '';
                data.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'item';
                    const name = result.display_name || '';

                    item.innerHTML = `
                        <div class="name">${name.split(',')[0]}</div>
                        <div class="addr">${name}</div>
                    `;

                    item.onclick = () => {
                        dropdown.style.display = 'none';
                        onSelect({
                            name,
                            lat: parseFloat(result.lat),
                            lng: parseFloat(result.lon)
                        });
                        input.value = name;
                    };

                    dropdown.appendChild(item);
                });
                dropdown.style.display = data.length ? 'block' : 'none';
            }

            /* =========================================================================
               MARKER & WAYPOINT METHODS
            ========================================================================= */
            icon(color, label) {
                return L.divIcon({
                    className: 'qpin',
                    iconSize: [32, 32],
                    iconAnchor: [16, 32],
                    html: `
                        <div style="width:32px;height:32px;border-radius:50%;background:${color};border:3px solid #fff;color:#fff;font-weight:800;display:grid;place-items:center;box-shadow:0 6px 20px rgba(0,0,0,.25);">
                            ${label}
                        </div>
                    `
                });
            }

            setFrom(location) {
                if (this.fromMarker) this.map.removeLayer(this.fromMarker);

                this.fromMarker = L.marker([location.lat, location.lng], {
                    icon: this.icon(COLORS.success, 'A')
                }).addTo(this.map).bindPopup(`<b>From:</b> ${location.name}`);

                this.map.setView([location.lat, location.lng], 13);
            }

            setTo(location) {
                if (this.toMarker) this.map.removeLayer(this.toMarker);

                this.toMarker = L.marker([location.lat, location.lng], {
                    icon: this.icon(COLORS.danger, 'B')
                }).addTo(this.map).bindPopup(`<b>To:</b> ${location.name}`);

                this.map.setView([location.lat, location.lng], 13);
                if (location.name) getElement('toInput').value = location.name;
            }

            swapFT() {
                const fromPos = this.fromMarker?.getLatLng();
                const toPos = this.toMarker?.getLatLng();

                if (!fromPos || !toPos) {
                    return this.toast('Set both points to swap', 'info');
                }

                this.fromMarker.setLatLng(toPos);
                this.toMarker.setLatLng(fromPos);

                const fromValue = getElement('fromInput').value;
                getElement('fromInput').value = getElement('toInput').value;
                getElement('toInput').value = fromValue;

                this.toast('Swapped points', 'info');
            }

            addWaypoint(latlng) {
                const index = this.places.filter(p => p.type === 'waypoint').length + 1;
                const id = Date.now();

                const marker = L.marker([latlng.lat, latlng.lng], {
                    icon: this.icon(COLORS.warning, index)
                }).addTo(this.map).bindPopup(`
                    <div style="text-align:center;">
                        <b>Waypoint ${index}</b><br>
                        Lat: ${latlng.lat.toFixed(6)}<br>
                        Lng: ${latlng.lng.toFixed(6)}
                        <button class="btn danger" style="margin-top:8px;padding:4px 12px;font-size:12px;width:100%;" 
                            onclick="window.quantumMaps.removeWaypoint(${id})">
                            <i class="fa-solid fa-trash"></i> Remove Waypoint
                        </button>
                    </div>
                `);

                this.places.push({ ...latlng, marker, type: 'waypoint', id: id });
                getElement('wayCount').textContent = this.places.filter(p => p.type === 'waypoint').length;
            }

            removeWaypoint(id) {
                const wpIndex = this.places.findIndex(p => p.type === 'waypoint' && p.id === id);
                if (wpIndex === -1) return;

                const wp = this.places[wpIndex];
                this.map.removeLayer(wp.marker);
                this.places.splice(wpIndex, 1);

                // Re-index remaining waypoints
                this.places.filter(p => p.type === 'waypoint').forEach((p, i) => {
                    const newIndex = i + 1;
                    p.marker.setIcon(this.icon(COLORS.warning, newIndex));
                    p.marker.setPopupContent(`
                        <div style="text-align:center;">
                            <b>Waypoint ${newIndex}</b><br>
                            Lat: ${p.lat.toFixed(6)}<br>
                            Lng: ${p.lng.toFixed(6)}
                            <button class="btn danger" style="margin-top:8px;padding:4px 12px;font-size:12px;width:100%;" 
                                onclick="window.quantumMaps.removeWaypoint(${p.id})">
                                <i class="fa-solid fa-trash"></i> Remove Waypoint
                            </button>
                        </div>
                    `);
                });

                getElement('wayCount').textContent = this.places.filter(p => p.type === 'waypoint').length;
                this.toast('Waypoint removed', 'info');
            }

            /* =========================================================================
               MODAL METHODS
            ========================================================================= */
            openWpModal() {
                this.wpSelected = null;
                getElement('wpAdd').disabled = true;
                getElement('wpSearchInput').value = '';
                getElement('wpDropdown').style.display = 'none';
                getElement('wpModalBackdrop').style.display = 'flex';
                setTimeout(() => getElement('wpSearchInput').focus(), 50);
            }

            closeWpModal() {
                getElement('wpModalBackdrop').style.display = 'none';
            }

            confirmAddWaypoint() {
                if (!this.wpSelected) return;

                this.addWaypoint({ lat: this.wpSelected.lat, lng: this.wpSelected.lng });
                this.map.setView([this.wpSelected.lat, this.wpSelected.lng], 15);
                this.toast('Waypoint added', 'success');
                this.closeWpModal();
            }

            /* =========================================================================
               ROUTING METHODS - USES CURRENT ALGORITHM (OPENROUTESERVICE)
            ========================================================================= */
            calculateTotalDistance(points) {
                let dist = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    dist += haversineKm(points[i], points[i + 1]);
                }
                return dist;
            }

            async buildRoute() {
                if (!this.fromMarker || !this.toMarker) {
                    return this.toast('Please set both From and To', 'error');
                }

                // Clear POIs before routing
                this.places = this.places.filter(place => {
                    if (place.type === 'place') {
                        this.map.removeLayer(place.marker);
                        return false;
                    }
                    return true;
                });

                const from = this.fromMarker.getLatLng();
                const to = this.toMarker.getLatLng();
                const waypoints = this.places.filter(p => p.type === 'waypoint')
                    .map(p => ({ lat: p.lat, lng: p.lng }));

                const locations = [
                    { lat: from.lat, lng: from.lng },
                    ...waypoints,
                    { lat: to.lat, lng: to.lng }
                ];

                // Calculate baseline distance for real-time comparison
                const baselineKm = this.calculateTotalDistance(locations);

                this.loading(true);
                this.status(this.qOpt ? 'Quantum processors optimizing route…' : 'Calculating optimal path…');

                try {
                    const quantumMode = this.qOpt ? (this.qSuper ? 'superposition' : 'quantum') : 'classical';
                    let data = null;

                    if (CONFIG.USE_BACKEND) {
                        console.log('🚀 Attempting Backend Connection:', CONFIG.BACKEND_URL);
                        console.log('Payload:', { locations, mode: quantumMode });
                        try {
                            const response = await fetch(CONFIG.BACKEND_URL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    locations,
                                    mode: quantumMode,
                                    traffic: this.qTraffic,
                                    transport: this.transport
                                })
                            });

                            data = await response.json();
                            if (!data?.success) throw new Error(data?.error || 'Backend returned error');
                        } catch (err) {
                            console.warn('Backend unavailable, fallback to OpenRouteService (Classical):', err.message);
                            this.status('Backend unreachable, using Classical Routing...');
                            // Fallback to Classical Mode (uses ORS for geometry)
                            data = await this.mockQuantumSolve(locations, 'classical');
                        }
                    } else {
                        data = await this.mockQuantumSolve(locations, quantumMode);
                    }

                    const color = this.qOpt ? (this.qSuper ? COLORS.superposition : COLORS.quantum) : COLORS.classical;
                    const routePoints = data.route;
                    const roadCoords = await this.fetchRoadPolylineForRoute(routePoints);

                    if (this.routeLine) this.map.removeLayer(this.routeLine);

                    this.routeLine = L.polyline(roadCoords, {
                        color,
                        weight: this.qSuper ? 7 : 5,
                        opacity: 0.9,
                        dashArray: this.qSuper ? '10 6' : null
                    }).addTo(this.map);

                    this.map.fitBounds(this.routeLine.getBounds(), { padding: [20, 20] });

                    const km = data.distance;
                    const minutes = Math.round(data.duration);
                    const optimization = data.optimization;

                    // Use backend instructions if available, otherwise use OSRM fetched ones
                    this.navigationInstructions = (data.navigation_instructions && data.navigation_instructions.length > 0)
                        ? data.navigation_instructions
                        : (this.fetchedInstructions || []);

                    const algoName = data.algorithm_used || (this.qOpt ? 'Quantum QAOA' : 'Classical');
                    this.showRouteBox(km, minutes, optimization, baselineKm, algoName);

                    if (this.qOpt) {
                        this.status(`Quantum route optimized — ${optimization}% efficiency`);
                    } else {
                        this.status(`Route calculated — ${formatDistance(km)}`);
                    }
                    this.toast(`Route ready — ${formatDistance(km)} · ${formatDuration(minutes)}`, 'success');

                    // Show Start Navigation button
                    const btn = document.getElementById('startNavBtn');
                    if (btn) btn.style.display = 'block';

                } catch (error) {
                    console.error(error);
                    this.toast('Route calculation or road mapping failed', 'error');
                } finally {
                    this.loading(false);
                    setTimeout(() => this.status('Quantum Systems Online'), 2200);
                }
            }

            formatOSRMInstruction(step) {
                const m = step.maneuver;
                const type = m.type; // turn, new name, depart, arrive, roundabout, merge, on ramp, off ramp, fork, end of road
                const modifier = m.modifier; // left, right, slight left, etc.
                const name = step.name || '';
                const ref = step.ref ? ` (${step.ref})` : '';
                const dest = step.destinations ? ` towards ${step.destinations.split(',')[0]}` : '';

                let text = '';

                // Capitalize first letter
                const cap = (s) => s ? s.charAt(0).toUpperCase() + s.slice(1) : '';

                switch (type) {
                    case 'turn':
                    case 'merge':
                    case 'fork':
                        text = `${cap(type)} ${modifier || ''} onto ${name || 'road'}${ref}`;
                        break;
                    case 'roundabout':
                    case 'rotary':
                        text = `At roundabout take exit ${m.exit || 1} onto ${name || 'road'}`;
                        break;
                    case 'depart':
                        text = `Head ${modifier || ''} on ${name || 'road'}`;
                        break;
                    case 'arrive':
                        text = `Arrive at destination`;
                        break;
                    case 'new name':
                        text = `Continue on ${name || 'road'}${ref}`;
                        break;
                    case 'ramp':
                    case 'on ramp':
                        text = `Take ramp ${modifier || ''} onto ${name || 'highway'}`;
                        break;
                    case 'off ramp':
                        text = `Take exit ${modifier || ''} towards ${dest || name}`;
                        break;
                    default:
                        text = `${cap(type)} ${modifier || ''} ${name ? 'on ' + name : ''}`;
                }

                // Clean up double spaces
                return text.replace(/\s+/g, ' ').trim();
            }

            async mockQuantumSolve(locations, mode) {
                const points = locations.map(p => ({ ...p }));
                const start = points.shift();
                const end = points.pop();
                const waypoints = points;

                const optimizedOrder = [start];
                let current = start;
                const remaining = [...waypoints];

                while (remaining.length) {
                    let bestIndex = 0;
                    let bestDistance = Infinity;

                    for (let i = 0; i < remaining.length; i++) {
                        const distance = haversineKm(current, remaining[i]);
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestIndex = i;
                        }
                    }

                    current = remaining.splice(bestIndex, 1)[0];
                    optimizedOrder.push(current);
                }

                optimizedOrder.push(end);

                let totalDistance = 0;
                for (let i = 0; i < optimizedOrder.length - 1; i++) {
                    totalDistance += haversineKm(optimizedOrder[i], optimizedOrder[i + 1]);
                }

                const modeConfig = TRANSPORT_MODES[this.transport];
                const trafficFactor = this.transport === 'driving' ? 1.25 : (this.transport === 'cycling' ? 1.05 : 1.0);
                let durationMinutes = (totalDistance / modeConfig.avgSpeedKmh) * 60 * trafficFactor;

                if (mode.includes('quantum')) durationMinutes *= 0.88;
                if (mode === 'superposition') durationMinutes *= 0.85;

                const optimization = mode === 'superposition' ? 22 : (mode === 'quantum' ? 16 : 0);

                return {
                    success: true,
                    route: optimizedOrder,
                    distance: totalDistance,
                    duration: durationMinutes,
                    optimization
                };
            }

            async fetchRoadPolylineForRoute(points) {
                const profile = TRANSPORT_MODES[this.transport].osrmProfile;

                // Initialize collected instructions container
                this.fetchedInstructions = [];

                const fetchLeg = async (pointA, pointB) => {
                    const coords = `${pointA.lng},${pointA.lat};${pointB.lng},${pointB.lat}`;
                    // Added steps=true to get instructions
                    const url = `https://router.project-osrm.org/route/v1/${profile}/${coords}?overview=full&geometries=geojson&steps=true`;

                    try {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error('OSRM error');

                        const data = await response.json();
                        const route = data?.routes?.[0];
                        const geometry = route?.geometry?.coordinates || [];

                        // Extract instructions from steps
                        if (route?.legs) {
                            for (const leg of route.legs) {
                                if (leg.steps) {
                                    for (const step of leg.steps) {
                                        this.fetchedInstructions.push({
                                            instruction: this.formatOSRMInstruction(step),
                                            distance: step.distance
                                        });
                                    }
                                }
                            }
                        }

                        return geometry.map(([lng, lat]) => [lat, lng]);
                    } catch (err) {
                        // Fallback instruction
                        const dist = haversineKm(pointA, pointB) * 1000;
                        this.fetchedInstructions.push({
                            instruction: `Head to next waypoint`,
                            distance: dist
                        });
                        return [[pointA.lat, pointA.lng], [pointB.lat, pointB.lng]];
                    }
                };

                const allCoords = [];
                for (let i = 0; i < points.length - 1; i++) {
                    const segment = await fetchLeg(points[i], points[i + 1]);
                    if (i === 0) {
                        allCoords.push(...segment);
                    } else {
                        allCoords.push(...segment.slice(1));
                    }
                    await sleep(CONFIG.SLEEP_BETWEEN_REQUESTS);
                }

                if (allCoords.length === 0 && points.length) {
                    allCoords.push([points[0].lat, points[0].lng]);
                }

                return allCoords;
            }

            /* =========================================================================
               NAVIGATION SIMULATION (Google Maps Style)
            ========================================================================= */
            /* =========================================================================
               REAL GPS NAVIGATION (Google Maps Style)
            ========================================================================= */
            startNavigation() {
                if (!this.routeLine) return this.toast('No route to navigate', 'error');
                if (!('geolocation' in navigator)) return this.toast('Geolocation not supported', 'error');

                // 1. Prepare UI
                getElement('routeBox').style.display = 'none';
                getElement('sidebar').style.transform = 'translateX(-110%)';
                getElement('navOverlay').style.display = 'block';
                getElement('toggle').style.display = 'none';

                // 2. Prepare Path
                this.navPath = this.routeLine.getLatLngs();
                if (Array.isArray(this.navPath[0]) && !this.navPath[0].lat) {
                    this.navPath = this.navPath.flat();
                }

                // Smooth the visuals (Chaikin's Algorithm)
                const smoothFactor = 0.25; // 25% corner cutting
                const iterations = 3;      // 3 passes for buttery smooth curves

                // Helper to smooth absolute lat/lngs
                const smoothPath = (points) => {
                    let output = points.map(p => ({ lat: p.lat, lng: p.lng }));

                    for (let k = 0; k < iterations; k++) {
                        if (output.length < 3) break;
                        const next = [];
                        next.push(output[0]); // Keep Start

                        for (let i = 0; i < output.length - 1; i++) {
                            const p0 = output[i];
                            const p1 = output[i + 1];

                            // Q: 25% dist, R: 75% dist
                            const q = {
                                lat: 0.75 * p0.lat + 0.25 * p1.lat,
                                lng: 0.75 * p0.lng + 0.25 * p1.lng
                            };
                            const r = {
                                lat: 0.25 * p0.lat + 0.75 * p1.lat,
                                lng: 0.25 * p0.lng + 0.75 * p1.lng
                            };
                            next.push(q);
                            next.push(r);
                        }
                        next.push(output[output.length - 1]); // Keep End
                        output = next;
                    }
                    return output;
                };

                // Generate smoothed visual path
                // Only smooth if we have enough points, otherwise it looks weird
                const visualPath = this.navPath.length > 2 ? smoothPath(this.navPath) : this.navPath;

                // 2b. Style Route like Google Maps (Cased Line: Dark Border + Light Center)
                // Create background line for the "border" effect
                if (this.routeBackLine) this.map.removeLayer(this.routeBackLine);
                this.routeBackLine = L.polyline(visualPath, {
                    weight: 16,
                    color: '#1a457e', // Dark Blue Border
                    opacity: 1.0,
                    lineCap: 'round',
                    lineJoin: 'round',
                    smoothFactor: 0.5 // High res
                }).addTo(this.map);
                this.routeBackLine.bringToBack();

                // Style the main line (foreground)
                // We create a new polyline for navigation mode to separate it from the original "logic" line
                // But previously we modified this.routeLine. 
                // Better to hide original routeLine and use a new visual one to avoid destructively smoothing the data.
                this.routeLine.setStyle({ opacity: 0 }); // Hide original jagged line for logic

                if (this.navVisualLine) this.map.removeLayer(this.navVisualLine);
                this.navVisualLine = L.polyline(visualPath, {
                    weight: 10,
                    color: '#4285F4', // Bright Google Blue
                    opacity: 1.0,
                    lineCap: 'round',
                    lineJoin: 'round',
                    smoothFactor: 0.5
                }).addTo(this.map);
                this.navVisualLine.bringToFront();

                // Precompute distances (Use ORIGINAL jagged path for accuracy)
                this.pathDistances = [0];
                let total = 0;
                for (let i = 0; i < this.navPath.length - 1; i++) {
                    total += this.navPath[i].distanceTo(this.navPath[i + 1]);
                    this.pathDistances.push(total);
                }
                this.totalPathLenMeters = total;

                // Prepare instructions
                if (!this.navigationInstructions || !this.navigationInstructions.length) {
                    this.mappedInstructions = [
                        { startDist: 0, endDist: total, instruction: "Head to destination" }
                    ];
                } else {
                    let instTotal = 0;
                    this.mappedInstructions = this.navigationInstructions.map(inst => {
                        const start = instTotal;
                        const dist = inst.distance || 0;
                        instTotal += dist;
                        return { ...inst, startDist: start, endDist: instTotal };
                    });
                }

                this.isNavigating = true;
                this.lastSpokenIndex = -1;
                this.currentHeading = 0; // Merged heading (GPS or Compass)

                // 3. User Marker (Arrow)
                if (this.navMarker) this.map.removeLayer(this.navMarker);

                // Custom Navigation Arrow Icon
                const arrowIcon = L.divIcon({
                    className: 'nav-arrow-icon',
                    html: `<div id="userArrow" style="
                        width: 24px;
                        height: 24px;
                        background: #4285F4;
                        border: 2px solid white;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                        transform-origin: center;
                        transition: transform 0.2s cubic-bezier(0.1, 0, 0.3, 1);
                    ">
                        <i class="fa-solid fa-location-arrow" style="color:white; font-size: 14px; margin-top:2px;"></i>
                    </div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });

                this.navMarker = L.marker([0, 0], { icon: arrowIcon }).addTo(this.map);

                this.speak("Starting navigation. GPS active.");
                this.toast("Waiting for GPS signal...", "info");

                // 4. Start Watching Position
                const options = {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                };

                this.watchId = navigator.geolocation.watchPosition(
                    (pos) => this.handleGPSUpdate(pos),
                    (err) => {
                        console.error(err);
                        this.toast("GPS Signal Lost", "error");
                    },
                    options
                );

                // 5. Start Watching Orientation (Compass)
                this.compassHandler = (e) => this.handleCompass(e);
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', this.compassHandler);
                }
            }

            handleCompass(e) {
                // iOS requires 'webkitCompassHeading', others use 'alpha'
                let heading = e.webkitCompassHeading || (360 - e.alpha);

                if (heading !== null && heading !== undefined) {
                    this.lastCompassHeading = heading;
                    // If not moving fast (likely stationary), update arrow immediately
                    if (!this.lastSpeed || this.lastSpeed < 1.0) {
                        this.updateArrowRotation(heading);
                    }
                }
            }

            handleGPSUpdate(pos) {
                if (!this.isNavigating) return;

                const lat = pos.coords.latitude;
                const lng = pos.coords.longitude;
                const speed = pos.coords.speed; // m/s
                let heading = pos.coords.heading;

                this.lastSpeed = speed;
                const userLoc = L.latLng(lat, lng);

                // Update Marker Position
                this.navMarker.setLatLng(userLoc);

                // Determine Heading Source
                // If moving (>1m/s) and GPS heading exists, use it.
                // Else fallback to compass.
                let finalHeading = this.lastCompassHeading || 0;

                if (speed && speed > 1.0 && heading !== null && !isNaN(heading)) {
                    finalHeading = heading;
                } else if (heading === null && this.lastPos && speed > 0.5) {
                    // Calc from calc bearing if moved enough
                    const y = Math.sin(lng * Math.PI / 180 - this.lastPos.lng * Math.PI / 180) * Math.cos(lat * Math.PI / 180);
                    const x = Math.cos(this.lastPos.lat * Math.PI / 180) * Math.sin(lat * Math.PI / 180) -
                        Math.sin(this.lastPos.lat * Math.PI / 180) * Math.cos(lat * Math.PI / 180) * Math.cos(lng * Math.PI / 180 - this.lastPos.lng * Math.PI / 180);
                    finalHeading = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
                }

                // Smooth update arrow
                this.updateArrowRotation(finalHeading);

                this.lastPos = { lat, lng };

                // Initial Zoom / Center
                if (!this.hasCentered) {
                    this.map.setView(userLoc, 20, { animate: true });
                    this.hasCentered = true;
                } else {
                    this.map.panTo(userLoc, { animate: true });
                }

                // Route Matching Logic
                let bestIdx = 0;
                let bestDist = Infinity;

                for (let i = 0; i < this.navPath.length; i++) {
                    const d = userLoc.distanceTo(this.navPath[i]);
                    if (d < bestDist) {
                        bestDist = d;
                        bestIdx = i;
                    }
                }

                if (bestDist > 50) {
                    getElement('navText').innerHTML = `<i class="fa-solid fa-triangle-exclamation"></i> Off Route`;
                    getElement('navNextDist').textContent = Math.round(bestDist) + "m away";
                    return;
                }

                // Gray out the traveled portion of the route
                if (this.navVisualLine && bestIdx > 0) {
                    const traveledPath = this.navPath.slice(0, bestIdx + 1);

                    if (!this.traveledLine) {
                        this.traveledLine = L.polyline(traveledPath, {
                            weight: 10,
                            color: '#9CA3AF', // Gray for traveled
                            opacity: 0.7,
                            lineCap: 'round',
                            lineJoin: 'round'
                        }).addTo(this.map);
                        this.traveledLine.bringToBack();
                    } else {
                        this.traveledLine.setLatLngs(traveledPath);
                    }
                }

                if (this.navPath.length > 0 &&
                    userLoc.distanceTo(this.navPath[this.navPath.length - 1]) < 20) {
                    this.speak("You have arrived.");
                    this.stopNavigation();
                    this.toast("You have arrived!", "success");
                    return;
                }

                this.updateNavUI(this.pathDistances[bestIdx]);
            }

            updateArrowRotation(heading) {
                const arrowEl = document.getElementById('userArrow');
                if (arrowEl) {
                    // Standard: 0 is North. fa-location-arrow (45deg NE). Correciton: -45.
                    arrowEl.style.transform = `rotate(${heading - 45}deg)`;
                }
            }

            stopNavigation() {
                this.isNavigating = false;
                this.hasCentered = false;
                if (this.watchId) navigator.geolocation.clearWatch(this.watchId);
                if (this.compassHandler) window.removeEventListener('deviceorientation', this.compassHandler);
                window.speechSynthesis.cancel();

                getElement('navOverlay').style.display = 'none';
                getElement('routeBox').style.display = 'block';
                getElement('sidebar').style.transform = 'translateX(0)';
                getElement('toggle').style.display = 'grid';

                if (this.navMarker) {
                    this.map.removeLayer(this.navMarker);
                    this.navMarker = null;
                }
                if (this.routeBackLine) {
                    this.map.removeLayer(this.routeBackLine);
                    this.routeBackLine = null;
                }
                if (this.traveledLine) {
                    this.map.removeLayer(this.traveledLine);
                    this.traveledLine = null;
                }

                // Reset UI
                const muteBtn = document.getElementById('navMute');
                const muteIcon = document.getElementById('muteIcon');
                if (muteBtn) muteBtn.classList.remove('muted');
                if (muteIcon) muteIcon.className = 'fa-solid fa-volume-high';
                this.isMuted = false;

                // Restore generic route style
                if (this.routeLine) {
                    this.routeLine.setStyle({
                        weight: 6,
                        color: COLORS.quantum,
                        opacity: 0.8
                    });
                    this.map.fitBounds(this.routeLine.getBounds(), { padding: [50, 50] });
                }
            }

            updateNavUI(currentDist) {
                // Find active instruction (same logic)
                const activeInst = this.mappedInstructions.find(i => currentDist >= i.startDist && currentDist < i.endDist)
                    || this.mappedInstructions[this.mappedInstructions.length - 1];

                if (activeInst) {
                    const distToNext = activeInst.endDist - currentDist;
                    const instructionText = activeInst.instruction || "Continue ahead";

                    // Dynamic turn icon based on instruction text
                    const iconMap = {
                        'left': 'fa-arrow-left',
                        'right': 'fa-arrow-right',
                        'u-turn': 'fa-rotate-left',
                        'straight': 'fa-arrow-up',
                        'slight left': 'fa-arrow-up-left',
                        'slight right': 'fa-arrow-up-right',
                        'arrive': 'fa-location-dot',
                        'roundabout': 'fa-rotate-right'
                    };

                    let iconClass = 'fa-arrow-up'; // default
                    const lowerInst = instructionText.toLowerCase();
                    for (const [keyword, icon] of Object.entries(iconMap)) {
                        if (lowerInst.includes(keyword)) {
                            iconClass = icon;
                            break;
                        }
                    }

                    const turnIcon = document.getElementById('turnIcon');
                    if (turnIcon) turnIcon.className = `fa-solid ${iconClass}`;

                    const instText = document.getElementById('instructionText');
                    if (instText) instText.textContent = instructionText;

                    getElement('navNextDist').textContent = distToNext > 1000
                        ? (distToNext / 1000).toFixed(1) + ' km'
                        : Math.round(distToNext) + ' m';

                    // Update progress bar
                    if (this.totalPathLenMeters > 0) {
                        const progress = Math.min((currentDist / this.totalPathLenMeters) * 100, 100);
                        const progressBar = document.getElementById('navProgressBar');
                        if (progressBar) progressBar.style.width = `${progress}%`;
                    }

                    // Update ETA dynamically
                    const remainingDist = Math.max(0, this.totalPathLenMeters - currentDist);
                    const speedMps = (this.lastSpeed && this.lastSpeed > 0) ? this.lastSpeed : 8.33; // default approx 30km/h
                    const remainingSeconds = remainingDist / speedMps;
                    const etaMinutes = Math.ceil(remainingSeconds / 60);

                    getElement('navETA').textContent = etaMinutes > 60
                        ? `${Math.floor(etaMinutes / 60)}h ${etaMinutes % 60}m`
                        : `${etaMinutes} min`;

                    // Update speed display
                    if (this.lastSpeed !== undefined) {
                        const speedKmh = Math.round(this.lastSpeed * 3.6);
                        const speedEl = getElement('navSpeed');
                        if (speedEl) speedEl.textContent = `${speedKmh} km/h`;
                    }

                    const instIndex = this.mappedInstructions.indexOf(activeInst);
                    if (instIndex !== this.lastInstructionIndex && !this.isMuted) {
                        this.speak(instructionText);
                        this.lastInstructionIndex = instIndex;
                    }
                }
            }

            speak(text) {
                if (!('speechSynthesis' in window) || this.isMuted) return;

                // Cancel any pending speech to avoid overlap
                window.speechSynthesis.cancel();

                const utterance = new SpeechSynthesisUtterance(text);

                // Try to use a natural voice
                const voices = window.speechSynthesis.getVoices();
                const preferredVoice = voices.find(v =>
                    v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Daniel') || v.name.includes('Natural'))
                ) || voices.find(v => v.lang.startsWith('en'));

                if (preferredVoice) utterance.voice = preferredVoice;

                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 0.9;

                window.speechSynthesis.speak(utterance);
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                const muteBtn = document.getElementById('navMute');
                const muteIcon = document.getElementById('muteIcon');

                if (muteBtn && muteIcon) {
                    if (this.isMuted) {
                        muteBtn.classList.add('muted');
                        muteIcon.className = 'fa-solid fa-volume-xmark';
                        window.speechSynthesis.cancel();
                    } else {
                        muteBtn.classList.remove('muted');
                        muteIcon.className = 'fa-solid fa-volume-high';
                    }
                }
            }

            /* =========================================================================
               POI SUB-OPTIONS METHODS
            ========================================================================= */
            startPOIFlow(type) {
                if (!POI_CONFIG[type]) {
                    this.nearby(type);
                    return;
                }

                this.currentPOIType = type;
                this.poiAnswers = {};
                this.currentPOIStep = 0;

                const panel = getElement('poiSubOptions');
                if (panel) {
                    panel.style.display = 'block';
                    // Scroll sidebar to show options
                    const sidebar = getElement('sidebar');
                    // Simple offset calculation
                    sidebar.scrollTo({ top: panel.offsetTop - 100, behavior: 'smooth' });
                }

                this.renderPOIStep();
            }

            renderPOIStep() {
                const config = POI_CONFIG[this.currentPOIType];
                let step = config.steps[this.currentPOIStep];

                // Check conditions - skip steps not valid for current answers
                while (step && step.condition && !step.condition(this.poiAnswers)) {
                    this.currentPOIStep++;
                    step = config.steps[this.currentPOIStep];
                }

                if (!step) {
                    this.finishPOISearch();
                    return;
                }

                getElement('poiQuestion').textContent = step.question;
                const optionsContainer = getElement('poiOptions');
                optionsContainer.innerHTML = '';

                step.options.forEach(opt => {
                    const chip = document.createElement('div');
                    chip.className = 'poi-chip';
                    chip.textContent = opt;
                    chip.onclick = () => this.handlePOIOption(step.id, opt);
                    optionsContainer.appendChild(chip);
                });
            }

            handlePOIOption(stepId, answer) {
                this.poiAnswers[stepId] = answer;
                this.currentPOIStep++;
                this.renderPOIStep();
            }

            finishPOISearch() {
                const panel = getElement('poiSubOptions');
                if (panel) panel.style.display = 'none';

                let type = this.currentPOIType;
                // Special handling for Banks option in ATM flow
                if (type === 'atm' && this.poiAnswers['service_type'] === 'Banks') {
                    type = 'bank';
                }
                const answers = Object.values(this.poiAnswers).join(' ');
                let query = `${answers} ${type}`;

                // Improve query for restaurants to ensure we get places
                if (type === 'restaurant' && !query.toLowerCase().includes('restaurant')) {
                    query += ' restaurant';
                }

                this.toast(`Searching for: ${query}`, 'success');
                console.log("Searching POI:", query);

                // Trigger generic search with the specific query
                this.nearby(type, query);
            }

            /* =========================================================================
               NEARBY SEARCH METHODS
            ========================================================================= */
            async nearby(type, customQuery = null) {
                if (!this.user || (!this.locationDetected && this.user === CONFIG.DEFAULT_LOCATION)) {
                    return this.toast('Using default location for nearby search', 'info');
                }

                const searchTerm = customQuery || type;
                this.loading(true);
                this.status(`Searching for all available ${searchTerm}s...`);

                // 1. Define Search Parameters
                const SEARCH_RADIUS = 20000; // 20km as requested
                const MAX_RESULTS = 50; // Increased limit to show "all" points

                // 2. Define Search Functions
                const fetchOverpass = async () => {
                    // Skip overpass for complex queries like "Non-Veg Breakfast" (unless standard type)
                    if (customQuery && !POI_TAGS[type]) return [];

                    const tag = POI_TAGS[type] || 'amenity=restaurant';
                    const query = `
                        [out:json][timeout:25];
                        (
                            node[${tag}](around:${SEARCH_RADIUS},${this.user.lat},${this.user.lng});
                            way[${tag}](around:${SEARCH_RADIUS},${this.user.lat},${this.user.lng});
                            relation[${tag}](around:${SEARCH_RADIUS},${this.user.lat},${this.user.lng});
                        );
                        out center ${MAX_RESULTS};
                    `;
                    try {
                        const res = await fetch('https://overpass-api.de/api/interpreter', {
                            method: 'POST', body: query
                        });
                        if (!res.ok) return [];
                        const data = await res.json();
                        return (data.elements || []).map(node => ({
                            lat: node.lat || node.center?.lat,
                            lng: node.lon || node.center?.lon,
                            name: node.tags?.name || (type.charAt(0).toUpperCase() + type.slice(1)),
                            source: 'overpass',
                            type: type
                        })).filter(p => p.lat && p.lng);
                    } catch (e) {
                        console.warn('Overpass failed', e);
                        return [];
                    }
                };

                const fetchNominatim = async () => {
                    const q = encodeURIComponent(searchTerm);
                    // Viewbox for prioritization, but we trust the results to be valid
                    const offset = 0.2; // approx 20km
                    const viewbox = `${this.user.lng - offset},${this.user.lat + offset},${this.user.lng + offset},${this.user.lat - offset}`;

                    try {
                        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${q}&viewbox=${viewbox}&bounded=1&limit=${MAX_RESULTS}`);
                        if (!res.ok) return [];
                        const data = await res.json();
                        return data.map(item => ({
                            lat: parseFloat(item.lat),
                            lng: parseFloat(item.lon),
                            name: item.display_name.split(',')[0],
                            source: 'nominatim',
                            type: type
                        }));
                    } catch (e) {
                        console.warn('Nominatim failed', e);
                        return [];
                    }
                };

                // 3. Execute Searches in Parallel
                this.status('Querying global databases...');
                const [overpassResults, nominatimResults] = await Promise.all([
                    fetchOverpass(),
                    fetchNominatim()
                ]);

                // 4. Merge and Deduplicate
                let allPlaces = [...overpassResults, ...nominatimResults];

                // Deduplicate based on proximity (very close points are likely the same POI)
                const uniquePlaces = [];
                allPlaces.forEach(p => {
                    const isDuplicate = uniquePlaces.some(existing => {
                        const dist = haversineKm(p, existing);
                        // If within 20 meters and names are somewhat similar
                        return dist < 0.02 && (p.name.includes(existing.name) || existing.name.includes(p.name));
                    });
                    if (!isDuplicate) uniquePlaces.push(p);
                });

                // 5. Filter by Radius (Strict) & Sort by Distance
                const finalList = uniquePlaces
                    .map(p => ({ ...p, dist: haversineKm(this.user, p) }))
                    .filter(p => p.dist <= (SEARCH_RADIUS / 1000))
                    .sort((a, b) => a.dist - b.dist);

                // 6. Render Results
                this.places = this.places.filter(place => {
                    if (place.type === 'place') {
                        this.map.removeLayer(place.marker);
                        return false;
                    }
                    return true;
                });

                if (finalList.length > 0) {
                    finalList.slice(0, MAX_RESULTS).forEach(p => {
                        const marker = L.marker([p.lat, p.lng], {
                            icon: this.icon(COLORS.quantum, '•')
                        }).addTo(this.map).bindPopup(`
                            <div style="text-align:center;">
                                <b>${p.name}</b><br>
                                <div style="color:#666;font-size:12px;">${formatDistance(p.dist)} away</div>
                                <div style="color:#999;font-size:10px;margin-bottom:8px;">Src: ${p.source}</div>
                                <button class="btn primary" style="padding:4px 12px;font-size:12px;width:100%;" 
                                    onclick="window.quantumMaps.setTo({lat:${p.lat}, lng:${p.lng}, name:'${p.name.replace(/'/g, "\\'")}'})">
                                    <i class="fa-solid fa-location-dot"></i> Set Destination
                                </button>
                            </div>
                        `);
                        this.places.push({ ...p, marker, type: 'place' });
                    });

                    // Fit bounds to all results
                    const group = L.featureGroup(this.places.map(p => p.marker));
                    this.map.fitBounds(group.getBounds().pad(0.2));

                    this.toast(`Found ${finalList.length} unique POIs`, 'success');
                } else {
                    this.toast(`No results found for "${searchTerm}" within 20km`, 'error');
                }

                this.loading(false);
                this.status('Quantum Systems Online');
            }

            /* =========================================================================
               UI UPDATE METHODS
            ========================================================================= */
            showRouteBox(km, minutes, optimization, baselineKm = 0, algorithmName = null) {
                getElement('routeBox').style.display = 'block';
                getElement('rDist').textContent = formatDistance(km);
                getElement('rEta').textContent = formatDuration(minutes);
                // Use actual algorithm name from backend if available, else usage setting
                const displayAlgo = algorithmName || (this.qOpt ? 'Quantum QAOA' : 'Classical');
                getElement('rAlgo').textContent = `${displayAlgo} · ${this.transport}`;
                getElement('rOpt').textContent = `${optimization}%`;

                // Calculate real savings
                let savedKm = 0;
                let savedMin = 0;

                if (baselineKm > km) {
                    savedKm = baselineKm - km;
                    // Estimate time saving assuming constant average speed
                    const speed = km / (minutes / 60); // km/h
                    const baselineMin = (baselineKm / speed) * 60;
                    savedMin = baselineMin - minutes;
                }

                getElement('distSave').textContent = savedKm > 0.05 ? formatDistance(savedKm) : '0 km';
                getElement('timeSave').textContent = savedMin > 0.5 ? formatDuration(Math.round(savedMin)) : '0 min';

                // Also update navigation stats panel
                getElement('navDist').textContent = formatDistance(km);
                getElement('navEta').textContent = formatDuration(minutes);
                getElement('navAlgo').textContent = displayAlgo;
                getElement('navOpt').textContent = `${optimization}%`;
            }

            status(message) {
                getElement('status').textContent = message;
            }

            updateMode() {
                const mode = this.qOpt ? (this.qSuper ? 'Q‑Super' : 'Quantum') : 'Classical';
                getElement('mode').textContent = mode;

                // Initialize to 0 if not set
                if (getElement('distSave').textContent === '—') {
                    getElement('distSave').textContent = '0 km';
                    getElement('timeSave').textContent = '0 min';
                }
            }

            toast(message, type = 'info') {
                const toast = getElement('toast');
                const messageElement = getElement('toastMsg');

                toast.className = `alert ${type}`;
                messageElement.textContent = message;
                toast.style.display = 'flex';

                clearTimeout(this._toastTimer);
                this._toastTimer = setTimeout(() => {
                    toast.style.display = 'none';
                }, CONFIG.TOAST_DURATION);
            }

            loading(visible) {
                getElement('loading').style.display = visible ? 'flex' : 'none';
            }

            /* =========================================================================
               UTILITY METHODS
            ========================================================================= */
            clearAll() {
                if (this.routeLine) {
                    this.map.removeLayer(this.routeLine);
                    this.routeLine = null;
                }

                // Clear alternative routes
                this.alternativeRouteLines.forEach(line => this.map.removeLayer(line));
                this.alternativeRouteLines = [];
                this.alternativeRoutes = [];

                if (this.fromMarker) {
                    this.map.removeLayer(this.fromMarker);
                    this.fromMarker = null;
                }

                if (this.toMarker) {
                    this.map.removeLayer(this.toMarker);
                    this.toMarker = null;
                }

                this.places.forEach(place => this.map.removeLayer(place.marker));
                this.places = [];

                getElement('fromInput').value = '';
                getElement('toInput').value = '';
                getElement('routeBox').style.display = 'none';
                getElement('wayCount').textContent = '0';

                // Clear vehicle analysis
                this.clearVehicleAnalysis();

                this.toast('Cleared', 'success');
            }

            goToUser(follow = false) {
                if (follow) {
                    this.follow = true;
                    getElement('recenterBtn').style.display = 'none';
                }

                this.map.setView([this.user.lat, this.user.lng], clamp(this.map.getZoom(), 14, 18), { animate: true });

                if (!this.locationDetected) {
                    this.toast('Showing default location (London)', 'info');
                }
            }

            useCurrentAsFrom() {
                const locationName = this.locationDetected ? 'Current Location' : 'Default Location (London)';

                this.setFrom({
                    name: locationName,
                    lat: this.user.lat,
                    lng: this.user.lng
                });
                getElement('fromInput').value = locationName;

                if (!this.locationDetected) {
                    this.toast('Using default location for starting point', 'info');
                }
            }

            /* =========================================================================
               VEHICLE FIT ANALYSIS METHODS - FIXED
            ========================================================================= */
            async analyzeVehicleFit() {
                // Reset state
                this.vehicleAnalysisShown = false;

                const vehicleType = getElement('vehicleType').value;
                let vehicleWidth, vehicleHeight, vehicleWeight, vehicleLength;

                if (vehicleType === 'custom') {
                    vehicleWidth = parseFloat(getElement('vehicleWidth').value) || 2.5;
                    vehicleHeight = parseFloat(getElement('vehicleHeight').value) || 3.5;
                    vehicleWeight = parseFloat(getElement('vehicleWeight').value) || 12;
                    vehicleLength = parseFloat(getElement('vehicleLength').value) || 12;
                } else {
                    const fallbackDims = {
                        'Toyota|Camry|2023': { width: 1.84, height: 1.45, length: 4.97, weight: 1.6 },
                        'Ford|F-150|2023': { width: 2.03, height: 1.98, length: 5.89, weight: 2.3 },
                        'Honda|CR-V|2023': { width: 1.86, height: 1.69, length: 4.69, weight: 1.7 },
                        'Tesla|Model 3|2023': { width: 1.85, height: 1.44, length: 4.69, weight: 1.8 },
                        'BMW|X5|2023': { width: 2.00, height: 1.75, length: 4.92, weight: 2.3 },
                        'Mercedes|Sprinter|2023': { width: 2.02, height: 2.72, length: 5.93, weight: 2.9 },
                        'Chevrolet|Tahoe|2023': { width: 2.06, height: 1.95, length: 5.35, weight: 2.6 },
                        'Volkswagen|Golf|2023': { width: 1.79, height: 1.46, length: 4.28, weight: 1.4 },
                        'Dodge|RAM 2500|2023': { width: 2.03, height: 2.04, length: 6.09, weight: 3.5 },
                        'Toyota|Sienna|2023': { width: 1.99, height: 1.78, length: 5.17, weight: 2.1 }
                    };

                    const selectedVehicle = getElement('vehicleSelect').value;
                    const dims = fallbackDims[selectedVehicle] || { width: 1.8, height: 1.5, length: 4.5, weight: 1.6 };

                    vehicleWidth = dims.width;
                    vehicleHeight = dims.height;
                    vehicleWeight = dims.weight;
                    vehicleLength = dims.length;
                }

                // Show analysis UI - ONLY ONCE
                getElement('vehicleAnalysisResults').style.display = 'block';
                getElement('fitStatus').style.display = 'flex';
                getElement('fitStatusText').textContent = 'Analyzing route constraints...';
                getElement('fitStatus').querySelector('.dot').style.backgroundColor = 'var(--warning)';

                try {
                    await sleep(1000);

                    // Simulate road analysis
                    const roadWidth = 3.5 + Math.random() * 0.5;
                    const bridgeHeight = 4.2 + Math.random() * 0.8;
                    const weightLimit = 25 + Math.random() * 15;
                    const turnRadius = 15 + Math.random() * 10;

                    const fits = vehicleWidth < roadWidth - 0.5 &&
                        vehicleHeight < bridgeHeight - 0.3 &&
                        vehicleWeight < weightLimit - 2 &&
                        vehicleLength * 1.3 < turnRadius;

                    // Display results
                    getElement('roadWidth').textContent = `${roadWidth.toFixed(1)}m`;
                    getElement('bridgeHeight').textContent = `${bridgeHeight.toFixed(1)}m`;
                    getElement('weightLimit').textContent = `${weightLimit.toFixed(0)} tons`;
                    getElement('turnRadius').textContent = `${turnRadius.toFixed(0)}m`;
                    getElement('fitDetails').style.display = 'block';

                    if (fits) {
                        // Vehicle FITS - SHOW SUCCESS MESSAGE ONCE
                        if (!this.vehicleAnalysisShown) {
                            getElement('fitStatusText').textContent = 'Vehicle fits on route ✓';
                            getElement('fitStatus').querySelector('.dot').style.backgroundColor = 'var(--success)';
                            getElement('alternativeRouteSection').style.display = 'none';
                            this.toast('Vehicle fits on the selected route', 'success');
                            this.vehicleAnalysisShown = true;
                        }
                    } else {
                        // Vehicle DOESN'T FIT - SHOW ERROR AND GENERATE ALTERNATIVES
                        if (!this.vehicleAnalysisShown) {
                            getElement('fitStatusText').textContent = 'Vehicle does not fit on route ✗';
                            getElement('fitStatus').querySelector('.dot').style.backgroundColor = 'var(--danger)';
                            this.toast('Vehicle does not fit on this route. Generating alternatives...', 'warning');
                            this.vehicleAnalysisShown = true;
                        }

                        // Store for alternative generation
                        this.currentFitAnalysis = {
                            fits: false,
                            vehicleWidth,
                            vehicleHeight,
                            vehicleWeight,
                            vehicleLength,
                            roadWidth,
                            bridgeHeight,
                            weightLimit,
                            turnRadius
                        };

                        // Visualize the vehicle scale on the map
                        this.drawVehicleFootprint(this.fromMarker ? this.fromMarker.getLatLng() : this.user, vehicleWidth, vehicleLength);

                        // Generate alternative routes automatically
                        await this.generateAlternativeRoutes();
                    }

                } catch (error) {
                    console.error('Vehicle analysis error:', error);
                    this.toast('Analysis failed', 'error');
                    getElement('fitStatusText').textContent = 'Analysis failed';
                    getElement('fitStatus').querySelector('.dot').style.backgroundColor = 'var(--danger)';
                }
            }

            async generateAlternativeRoutes() {
                if (!this.fromMarker || !this.toMarker) {
                    this.toast('Please create a route first', 'error');
                    return;
                }

                const from = this.fromMarker.getLatLng();
                const to = this.toMarker.getLatLng();

                // Calculate direct distance for reference
                const directDistance = haversineKm(
                    { lat: from.lat, lng: from.lng },
                    { lat: to.lat, lng: to.lng }
                );

                this.loading(true);
                this.status('Searching for alternative routes...');

                try {
                    // Use OpenRouteService API to get alternative routes
                    let profile = TRANSPORT_MODES[this.transport].orsProfile;
                    let useHGV = false;

                    // Intelligently switch to HGV if needed for larger vehicles
                    if (this.currentFitAnalysis && !this.currentFitAnalysis.fits && this.transport === 'driving') {
                        // If vehicle analysis failed, we MUST use a profile that respects dimensions
                        // Check if it's a large vehicle (mock check based on dimensions)
                        if (this.currentFitAnalysis.vehicleWidth > 2.0 || this.currentFitAnalysis.vehicleWeight > 3.5) {
                            profile = 'driving-hgv'; // Use HGV profile for strict dimension filtering
                            useHGV = true;
                        }
                    }

                    const url = `${CONFIG.ORS_BASE_URL}/directions/${profile}`;

                    const requestBody = {
                        coordinates: [
                            [from.lng, from.lat],
                            [to.lng, to.lat]
                        ],
                        alternative_routes: {
                            share_factor: 0.5,
                            target_count: 3,
                            weight_factor: 1.25
                        },
                        preference: 'recommended'
                    };

                    // Add strict dimension constraints if using HGV profile
                    if (useHGV && this.currentFitAnalysis) {
                        requestBody.options = {
                            profile_params: {
                                restrictions: {
                                    width: this.currentFitAnalysis.vehicleWidth,
                                    height: this.currentFitAnalysis.vehicleHeight,
                                    weight: this.currentFitAnalysis.vehicleWeight,
                                    length: this.currentFitAnalysis.vehicleLength,
                                    axleload: this.currentFitAnalysis.vehicleWeight / 2
                                }
                            }
                        };
                    }

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': CONFIG.ORS_API_KEY
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        throw new Error('OpenRouteService API error');
                    }

                    const data = await response.json();
                    const routes = data.routes || [];

                    // Clear previous alternative routes
                    this.alternativeRouteLines.forEach(line => this.map.removeLayer(line));
                    this.alternativeRouteLines = [];
                    this.alternativeRoutes = [];

                    if (routes.length > 1) {
                        // Store alternative routes (skip the first one as it's the primary route)
                        this.alternativeRoutes = routes.slice(1);

                        // Show alternative routes section
                        getElement('alternativeRouteSection').style.display = 'block';
                        getElement('alternativeRoutesAvailable').style.display = 'block';
                        getElement('noAlternativeRoutes').style.display = 'none';
                        getElement('routeCountText').textContent = `${this.alternativeRoutes.length} alternative route${this.alternativeRoutes.length > 1 ? 's' : ''} available`;

                        // Clear and populate route options
                        const routeOptionsContainer = getElement('routeOptions');
                        routeOptionsContainer.innerHTML = '';

                        this.alternativeRoutes.forEach((route, index) => {
                            const distance = (route.summary.distance / 1000).toFixed(2);
                            const duration = Math.round(route.summary.duration / 60);

                            const routeButton = document.createElement('button');
                            routeButton.className = 'btn ghost';
                            routeButton.style.fontSize = '12px';
                            routeButton.style.padding = '8px 12px';
                            routeButton.style.justifyContent = 'flex-start';
                            // Determine badge based on vehicle size
                            let badgeHtml = '';
                            if (route.isOversize || (this.currentFitAnalysis && this.currentFitAnalysis.vehicleWidth > 2.9)) {
                                badgeHtml = `
                                    <span style="font-size:10px;background:var(--warning);color:#000;padding:2px 6px;border-radius:4px;font-weight:700;">
                                        <i class="fa-solid fa-triangle-exclamation"></i> Oversize Load
                                    </span>
                                `;
                            } else {
                                badgeHtml = `
                                    <span style="font-size:10px;background:var(--success);color:#fff;padding:2px 6px;border-radius:4px;font-weight:700;">
                                        <i class="fa-solid fa-check"></i> Verified Fit
                                    </span>
                                `;
                            }

                            routeButton.innerHTML = `
                                <div style="display:flex;align-items:center;width:100%;justify-content:space-between;">
                                    <div style="display:flex;align-items:center;gap:6px;">
                                        <i class="fa-solid fa-route"></i>
                                        <span>Route ${index + 1}: ${distance} km · ${duration} min</span>
                                    </div>
                                    ${badgeHtml}
                                </div>
                            `;

                            routeButton.onclick = () => this.selectAlternativeRoute(index);
                            routeOptionsContainer.appendChild(routeButton);
                        });

                        this.toast(`Found ${this.alternativeRoutes.length} alternative route${this.alternativeRoutes.length > 1 ? 's' : ''}`, 'success');

                    } else {
                        // No alternative routes found
                        getElement('alternativeRouteSection').style.display = 'block';
                        getElement('alternativeRoutesAvailable').style.display = 'none';
                        getElement('noAlternativeRoutes').style.display = 'block';
                        this.toast('No alternative routes available for this vehicle', 'info');
                    }

                } catch (error) {
                    console.error('Alternative route generation error:', error);

                    // Fallback: Create mock alternative routes
                    this.alternativeRoutes = this.createMockAlternativeRoutes();

                    if (this.alternativeRoutes.length > 0) {
                        getElement('alternativeRouteSection').style.display = 'block';
                        getElement('alternativeRoutesAvailable').style.display = 'block';
                        getElement('noAlternativeRoutes').style.display = 'none';
                        getElement('routeCountText').textContent = `${this.alternativeRoutes.length} alternative route${this.alternativeRoutes.length > 1 ? 's' : ''} available`;

                        const routeOptionsContainer = getElement('routeOptions');
                        routeOptionsContainer.innerHTML = '';

                        this.alternativeRoutes.forEach((route, index) => {
                            const routeButton = document.createElement('button');
                            routeButton.className = 'btn ghost';
                            routeButton.style.fontSize = '12px';
                            routeButton.style.padding = '8px 12px';
                            routeButton.style.justifyContent = 'flex-start';
                            // Determine badge based on route logic (mock)
                            let badgeHtml = '';
                            if (route.isOversize) {
                                badgeHtml = `
                                    <span style="font-size:10px;background:var(--warning);color:#000;padding:2px 6px;border-radius:4px;font-weight:700;">
                                        <i class="fa-solid fa-triangle-exclamation"></i> Oversize Load
                                    </span>
                                `;
                            } else {
                                badgeHtml = `
                                    <span style="font-size:10px;background:var(--success);color:#fff;padding:2px 6px;border-radius:4px;font-weight:700;">
                                        <i class="fa-solid fa-check"></i> Verified Fit
                                    </span>
                                `;
                            }

                            routeButton.innerHTML = `
                                <div style="display:flex;align-items:center;width:100%;justify-content:space-between;">
                                    <div style="display:flex;align-items:center;gap:6px;">
                                        <i class="fa-solid fa-route"></i>
                                        <span>Route ${index + 1}: ${route.distance.toFixed(2)} km · ${route.duration} min</span>
                                    </div>
                                    ${badgeHtml}
                                </div>
                            `;

                            routeButton.onclick = () => this.selectAlternativeRoute(index);
                            routeOptionsContainer.appendChild(routeButton);
                        });

                        this.toast('Using demo alternative routes (API unavailable)', 'info');
                    } else {
                        getElement('alternativeRouteSection').style.display = 'block';
                        getElement('alternativeRoutesAvailable').style.display = 'none';
                        getElement('noAlternativeRoutes').style.display = 'block';
                        this.toast('No alternative routes available', 'info');
                    }

                } finally {
                    this.loading(false);
                    this.status('Quantum Systems Online');
                }
            }

            createMockAlternativeRoutes() {
                if (!this.fromMarker || !this.toMarker) return [];

                // STRICT REALITY CHECK & OVERSIZE LOGIC:
                // Standard lane is ~3.5m.
                // Vehicles > 2.6m are "Wide Load".
                // Vehicles > 3.8m are "Super Load" / "Exception" (Police escort required).
                // We will ALLOW these but flag them clearly.

                if (this.currentFitAnalysis) {
                    const MAX_POSSIBLE_WIDTH = 10.0; // Allow super loads up to 10m
                    const MAX_POSSIBLE_HEIGHT = 6.0;

                    if (this.currentFitAnalysis.vehicleWidth > MAX_POSSIBLE_WIDTH) {
                        this.toast(`Vehicle width (${this.currentFitAnalysis.vehicleWidth}m) is physically impossible on public infrastructure!`, 'error');
                        return [];
                    }
                }

                const from = this.fromMarker.getLatLng();
                const to = this.toMarker.getLatLng();
                const totalDistance = haversineKm(from, to);

                // Create 2-3 mock alternative routes with variations
                const numRoutes = Math.floor(Math.random() * 2) + 2; // 2 or 3 routes
                const mockRoutes = [];

                // Calculate vector components for perpendicular offset
                const dx = to.lng - from.lng;
                const dy = to.lat - from.lat;

                // Perpendicular vector (-dy, dx)
                // Normalize it roughly to handle degrees (latitude correction needed for real precision but this is mock)
                const len = Math.sqrt(dx * dx + dy * dy);
                const pdx = -dy / len;
                const pdy = dx / len;

                for (let i = 0; i < numRoutes; i++) {
                    const direction = i % 2 === 0 ? 1 : -1; // Alternate sides
                    const offsetFactor = 0.15 + (Math.random() * 0.1); // Offset magnitude relative to straight line length

                    // Offset magnitude in degrees (approx)
                    const offsetMag = len * offsetFactor * direction;

                    // Calculate midpoint with offset
                    const midLat = (from.lat + to.lat) / 2 + (pdy * offsetMag);
                    const midLng = (from.lng + to.lng) / 2 + (pdx * offsetMag);

                    // Add some distance penalty
                    const distance = totalDistance * (1.2 + (Math.random() * 0.2));
                    const duration = Math.round((distance / TRANSPORT_MODES[this.transport].avgSpeedKmh) * 60 * 1.1);

                    const isOversize = this.currentFitAnalysis && this.currentFitAnalysis.vehicleWidth > 2.9;
                    const badgeColor = isOversize ? 'var(--warning)' : 'var(--success)';
                    const badgeText = isOversize ? '<i class="fa-solid fa-triangle-exclamation"></i> Oversize Load' : '<i class="fa-solid fa-check"></i> Verified Fit';
                    const badgeStyle = isOversize ? 'background:var(--warning);color:#000;' : 'background:var(--success);color:#fff;';

                    mockRoutes.push({
                        distance,
                        duration,
                        isOversize,
                        coordinates: [
                            [from.lng, from.lat],
                            [midLng, midLat], // Midpoint
                            [to.lng, to.lat]
                        ]
                    });
                }

                return mockRoutes;
            }

            async selectAlternativeRoute(index) {
                if (index < 0 || index >= this.alternativeRoutes.length) return;

                const route = this.alternativeRoutes[index];
                this.loading(true);

                try {
                    // Clear previous alternative route lines
                    this.alternativeRouteLines.forEach(line => this.map.removeLayer(line));
                    this.alternativeRouteLines = [];

                    let coordinates;

                    if (route.geometry && route.geometry.coordinates) {
                        // OpenRouteService format
                        coordinates = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                    } else if (route.coordinates) {
                        // Mock format - need to get road polyline
                        const points = route.coordinates.map(coord => ({ lat: coord[1], lng: coord[0] }));
                        coordinates = await this.fetchRoadPolylineForRoute(points);
                    } else {
                        throw new Error('Invalid route format');
                    }

                    // Draw the alternative route
                    const colors = [COLORS.alternative1, COLORS.alternative2, COLORS.alternative3];
                    const color = colors[index % colors.length];

                    const routeLine = L.polyline(coordinates, {
                        color: color,
                        weight: 5,
                        opacity: 0.8,
                        dashArray: '10 5'
                    }).addTo(this.map);

                    this.alternativeRouteLines.push(routeLine);
                    this.map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });

                    // Update route box with alternative route info
                    const distance = route.summary ? (route.summary.distance / 1000) : route.distance;
                    const duration = route.summary ? Math.round(route.summary.duration / 60) : route.duration;

                    this.showRouteBox(distance, duration, this.qOpt ? 16 : 0);
                    this.toast(`Alternative Route ${index + 1} selected`, 'success');

                    // Highlight selected button
                    document.querySelectorAll('#routeOptions .btn').forEach((btn, i) => {
                        if (i === index) {
                            btn.style.background = '#e9f1ff';
                            btn.style.color = 'var(--primary)';
                            btn.style.fontWeight = '700';
                        } else {
                            btn.style.background = '#f3f6fb';
                            btn.style.color = 'inherit';
                            btn.style.fontWeight = '600';
                        }
                    });

                } catch (error) {
                    console.error('Error selecting alternative route:', error);
                    this.toast('Failed to load alternative route', 'error');
                } finally {
                    this.loading(false);
                }
            }

            clearVehicleAnalysis() {
                getElement('vehicleAnalysisResults').style.display = 'none';
                getElement('fitDetails').style.display = 'none';
                getElement('alternativeRouteSection').style.display = 'none';
                getElement('vehicleType').value = 'car';
                getElement('customVehicle').style.display = 'none';
                getElement('vehicleSelectContainer').style.display = 'block';

                // Clear alternative routes from map
                this.alternativeRouteLines.forEach(line => this.map.removeLayer(line));
                this.alternativeRouteLines = [];
                this.alternativeRoutes = [];

                if (this.vehicleParams?.footprint) {
                    this.map.removeLayer(this.vehicleParams.footprint);
                    this.vehicleParams.footprint = null;
                }

                this.vehicleAnalysisShown = false;
                this.currentFitAnalysis = null;
            }

            drawVehicleFootprint(latlng, widthMeters, lengthMeters) {
                if (this.vehicleParams?.footprint) {
                    this.map.removeLayer(this.vehicleParams.footprint);
                }

                // Convert meters to lat/lng degrees (approximate)
                // 1 degree lat ~= 111,320m
                // 1 degree lng ~= 111,320m * cos(lat)
                const metersPerLat = 111320;
                const metersPerLng = 111320 * Math.cos(latlng.lat * Math.PI / 180);

                const dLat = (lengthMeters / 2) / metersPerLat;
                const dLng = (widthMeters / 2) / metersPerLng;

                const bounds = [
                    [latlng.lat - dLat, latlng.lng - dLng],
                    [latlng.lat + dLat, latlng.lng + dLng]
                ];

                // Draw the vehicle footprint
                const footprint = L.rectangle(bounds, {
                    color: '#ea4335',
                    weight: 2,
                    fillColor: '#ea4335',
                    fillOpacity: 0.35,
                    dashArray: '5, 5'
                }).addTo(this.map);

                if (!this.vehicleParams) this.vehicleParams = {};
                this.vehicleParams.footprint = footprint;

                // Zoom closely to show the scale comparison
                this.map.flyTo([latlng.lat, latlng.lng], 19, { animate: true, duration: 1.5 });

                this.toast(`Visualizing vehicle scale: ${widthMeters}m x ${lengthMeters}m`, 'info');
            }
        }

        /* =============================================================================
           APPLICATION INITIALIZATION
        ============================================================================= */
        window.addEventListener('DOMContentLoaded', () => {
            window.quantumMaps = new QuantumMaps();
        });
    </script>
</body>

</html>